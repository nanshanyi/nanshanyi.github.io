<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[iOS自定义转场动画]]></title>
      <url>http://nanshanyi.github.io/2020/01/02/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<h5 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h5><p>　　iOS的新页面的弹出方式分为两种<strong>Push&amp;Pop</strong>和<strong>Present&amp;Dismiss</strong>，转场方式的自定义也主要针对这两种方式进行。其中<strong>Push&amp;Pop</strong>方式需要针对Push和Pop分别定义动画，也就是说需要分别创建动画文件。而<strong>Present&amp;Dismiss</strong>方式的话只需要一个即可。<br><a id="more"></a></p>
<h5 id="Push-amp-Pop方式"><a href="#Push-amp-Pop方式" class="headerlink" title="Push&amp;Pop方式"></a>Push&amp;Pop方式</h5><h6 id="动画文件"><a href="#动画文件" class="headerlink" title="动画文件"></a>动画文件</h6><p>　　首先来看一下动画文件的实现 <br><br>1、先创建一个类继承自NSObject <br><br>2、遵守协议UIViewControllerAnimatedTransitioning <br><br>3、接下来主要实现三个方法即可 <br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PushTransition</span> : <span class="title">NSObject</span>&lt;<span class="title">UIViewControllerAnimatedTransitioning</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="keyword">id</span> transitionContext;<span class="comment">//专场上下文，用来协调，from和to的页面</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIViewController</span> *fromViewController;<span class="comment">//push操作主要针对fromViewController做动画</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h6 id="First"><a href="#First" class="headerlink" title="First"></a>First</h6><p>　　主要用来返回动画执行时间,即为push动画的时间，直接return一个时间即可，单位为秒</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h6><p>　　下面这个方法就主要涉及到动画的实现了，需要对FromViewController的view做动画，来实现push的动画效果，主要解释已在注释里面写的很清楚了</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext</span><br><span class="line">&#123;_transitionContext = transitionContext;<span class="comment">//首先记录transitionContext，下面的方法会用到</span></span><br><span class="line">    <span class="comment">//我们主要通过这个transitionContext来获取需要做动画的fromViewController和toViewController,fromView和toView</span></span><br><span class="line">    <span class="comment">//通过viewControllerForKey:这个方法来获取，有两个key来获取相应的Controller</span></span><br><span class="line">    <span class="comment">// Currently only two keys are defined by the system:</span></span><br><span class="line">    <span class="comment">//   UITransitionContextToViewControllerKey  获取要出现的Controller</span></span><br><span class="line">    <span class="comment">//   UITransitionContextFromViewControllerKey 获取要消失的Controller</span></span><br><span class="line">    <span class="comment">// Currently only two keys are defined by the system:</span></span><br><span class="line">    <span class="comment">//   UITransitionContextToViewKey //获取要出现的view即上面toViewController的View</span></span><br><span class="line">    <span class="comment">//   UITransitionContextFromViewKey //获取要出现的view即fromViewController的View</span></span><br><span class="line">    <span class="built_in">UIView</span> *fromView = [transitionContext viewForKey:<span class="built_in">UITransitionContextFromViewKey</span>];</span><br><span class="line">    <span class="built_in">UIView</span> *toView = [transitionContext viewForKey:<span class="built_in">UITransitionContextToViewKey</span>];</span><br><span class="line">    <span class="comment">//拿到ContainerView</span></span><br><span class="line">    <span class="built_in">UIView</span> *containerView = [transitionContext containerView];</span><br><span class="line">    <span class="comment">//把fromView和toView都加到containerView中，在容器中是完成动画</span></span><br><span class="line">    [containerView addSubview:toView];</span><br><span class="line">    [containerView addSubview:fromView];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CATransform3D类型的四维仿射变换矩阵，并且提供预置好的进行旋转、变形之后的仿射变换矩阵，m34来控制透视效果,有兴趣的话可以在自己了解一下</span></span><br><span class="line">    <span class="built_in">CATransform3D</span> transform = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">    transform.m34 = <span class="number">-1</span>/<span class="number">500.0</span>;</span><br><span class="line">    fromView.layer.transform = transform;</span><br><span class="line">    fromView.layer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">    fromView.layer.position = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="built_in">CGRectGetMidY</span>(fromView.frame));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动画变化</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">2</span> animations:^&#123;</span><br><span class="line"></span><br><span class="line">        fromView.layer.transform = <span class="built_in">CATransform3DMakeRotation</span>(-M_PI_2, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line"><span class="comment">// This must be called whenever a transition completes (or is cancelled.)</span></span><br><span class="line"><span class="comment">// Typically this is called by the object conforming to the</span></span><br><span class="line"><span class="comment">// UIViewControllerAnimatedTransitioning protocol that was vended by the transitioning</span></span><br><span class="line"><span class="comment">// delegate.  For purely interactive transitions it should be called by the</span></span><br><span class="line"><span class="comment">// interaction controller. This method effectively updates internal view</span></span><br><span class="line"><span class="comment">// controller state at the end of the transition.</span></span><br><span class="line"><span class="comment">//动画完成后必须调用</span></span><br><span class="line">        [_transitionContext finishInteractiveTransition];</span><br><span class="line">        [_transitionContext completeTransition:<span class="literal">YES</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pop的话，其实跟Push差不多这里就只贴代码不做过多解释了</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext&#123;</span><br><span class="line">    </span><br><span class="line">    _transitionContext = transitionContext;</span><br><span class="line">    <span class="built_in">UIViewController</span> *fromViewController = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</span><br><span class="line">    <span class="built_in">UIViewController</span> *toViewController = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</span><br><span class="line">    [fromViewController.view.layer removeAllAnimations];    </span><br><span class="line">    <span class="built_in">UIView</span> *containerView = [transitionContext containerView];</span><br><span class="line">    </span><br><span class="line">    [containerView addSubview:fromViewController.view];</span><br><span class="line">    [containerView addSubview:toViewController.view];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CATransform3D</span> transform = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">    transform.m34 = <span class="number">-1</span>/<span class="number">500.0</span>;</span><br><span class="line">    toViewController.view.layer.transform = transform;</span><br><span class="line">    toViewController.view.layer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">    toViewController.view.layer.position = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="built_in">CGRectGetMidY</span>(fromViewController.view.frame));</span><br><span class="line">    toViewController.view.layer.transform = <span class="built_in">CATransform3DMakeRotation</span>(-M_PI_2, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">2</span> animations:^&#123;</span><br><span class="line">        </span><br><span class="line">        toViewController.view.layer.transform = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">        [_transitionContext finishInteractiveTransition];</span><br><span class="line">        [_transitionContext completeTransition:<span class="literal">YES</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="present和dismiss"><a href="#present和dismiss" class="headerlink" title="present和dismiss"></a>present和dismiss</h5><p>　　这里先简单提一下代理，OC中的代理，实在是十分好用，为了将我们的代码耦合性降低。我们可以单独生成一个类，来实现动画，这样的话可以精简Controller里面的代码，另外是代码的复用性进一步增加。动画文件可以单独放在任何地方应用。<br>下面我们来实现.h</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先遵循以下两个协议，要实现自定义转场必须遵守的</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ModalTransition</span> : <span class="title">NSObject</span> &lt;<span class="title">UIViewControllerTransitioningDelegate</span>,<span class="title">UIViewControllerAnimatedTransitioning</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isPresent;<span class="comment">//记录是Present还是Dimiss</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>.m实现，这里我只是很简单的写了一个弹簧动画，对于动画方式大家可以自由发挥，写出更加炫酷的效果</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ModalTransition</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个代理方法要返回一个遵循UIViewControllerAnimatedTransitioning协议的对象，返回self即可。记录一下是Present还是Dimiss。主要讲解我还放在注释里面</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source&#123;</span><br><span class="line">    _isPresent = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed&#123;</span><br><span class="line">    _isPresent = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回动画时间</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据_isPresent来执行不同的动画</span></span><br><span class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext&#123;</span><br><span class="line">    _isPresent ? [<span class="keyword">self</span> animationForPresentedView:transitionContext] : [<span class="keyword">self</span> animationForDismissView:transitionContext];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义方法，Present的动画实现</span></span><br><span class="line">-(<span class="keyword">void</span>)animationForPresentedView:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext&#123;</span><br><span class="line">    <span class="built_in">UIView</span> *presentedView = [transitionContext viewForKey:<span class="built_in">UITransitionContextToViewKey</span>];</span><br><span class="line">    <span class="built_in">UIView</span> *fromView = [transitionContext viewForKey:<span class="built_in">UITransitionContextFromViewKey</span>];</span><br><span class="line"><span class="comment">//注意添加的次序</span></span><br><span class="line">    [[transitionContext containerView] addSubview:fromView];</span><br><span class="line">    [[transitionContext containerView] addSubview:presentedView];</span><br><span class="line">    presentedView.transform = <span class="built_in">CGAffineTransformTranslate</span>(presentedView.transform, <span class="number">0</span>, <span class="number">667</span>);</span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:[<span class="keyword">self</span> transitionDuration:transitionContext] delay:<span class="number">0</span> usingSpringWithDamping:<span class="number">0.6</span> initialSpringVelocity:<span class="number">0</span> options:<span class="built_in">UIViewAnimationOptionCurveEaseInOut</span> animations:^&#123;</span><br><span class="line">        presentedView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line"><span class="comment">//完成后记得调用completeTransition:方法</span></span><br><span class="line">        [transitionContext completeTransition:<span class="literal">YES</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义方法，Present的动画实现</span></span><br><span class="line">-(<span class="keyword">void</span>)animationForDismissView:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext&#123;</span><br><span class="line">    <span class="built_in">UIView</span> *dismissedView = [transitionContext viewForKey:<span class="built_in">UITransitionContextFromViewKey</span>];</span><br><span class="line">    <span class="built_in">UIView</span> *toView = [transitionContext viewForKey:<span class="built_in">UITransitionContextToViewKey</span>];</span><br><span class="line">    [[transitionContext containerView] addSubview:toView];</span><br><span class="line"><span class="comment">//注意添加的次序</span></span><br><span class="line">    [[transitionContext containerView] addSubview:dismissedView];</span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:[<span class="keyword">self</span> transitionDuration:transitionContext] animations:^&#123;</span><br><span class="line">        dismissedView.transform = <span class="built_in">CGAffineTransformTranslate</span>(dismissedView.transform, <span class="number">0</span>, <span class="number">667</span>);</span><br><span class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line"><span class="comment">//完成后记得调用completeTransition:方法</span></span><br><span class="line">        [transitionContext completeTransition:<span class="literal">YES</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   PresentViewController *presentController = [[PresentViewController alloc]init];</span><br><span class="line">    presentController.modalTransitionStyle = <span class="built_in">UIModalPresentationCustom</span>;</span><br><span class="line">    presentController.transitioningDelegate = _Transition;<span class="comment">//_Transition即为上面冬瓜文件生成的对象，这样就可以使用自定义的present动画</span></span><br><span class="line">    [<span class="keyword">self</span> presentViewController:presentController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>　　到这里基本就实现完成了，不管是Pop&amp;Push还是Present&amp;Dismiss你都可以实现任何你想要的炫酷效果（当然前提是你能把炫酷的动画优雅的实现出来），我这里只是抛砖引玉，期待你有更完美，漂亮的动画效果。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[刨根问底+load方法]]></title>
      <url>http://nanshanyi.github.io/2019/12/05/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95-load%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;首先我们都知道在iOS应用启动的时候会调用所有类和其分类的+load方法。子类的load方法会在父类方法执行完成之后执行，分类的+load会在主类执行之后执行。不可继承，子类没有实现的时候，文件加载的时候是不会调用父类的load方法的。那么为什么+load的方法会有这样的特性，runtime又有哪些巧妙的处理呢。今天我们来刨根问底一下+load方法。<br><a id="more"></a><br>&emsp;&emsp;首先解释两个变量和两个结构体，可以先看一眼有个印象，后面遇到再回来仔细察看</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次调用add_class_to_loadable_list()方法都会++，记录这个方法的调用次数，也相当于Class中+load方法列表的个数 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> loadable_classes_used = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//同上，只不过对应的是add_category_to_loadable_list()方法和Category中的+load方法列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> loadable_categories_used = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//存储了+load方法所属的Class和+load方法的IMP</span></span><br><span class="line"><span class="keyword">struct</span> loadable_class &#123;</span><br><span class="line">    Class cls;  <span class="comment">// may be nil</span></span><br><span class="line">    IMP method;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//同上，只不过对应的是Category</span></span><br><span class="line"><span class="keyword">struct</span> loadable_category &#123;</span><br><span class="line">    Category cat;  <span class="comment">// may be nil</span></span><br><span class="line">    IMP method;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存储Class和categoty这两个struct数据的是数组</span></span><br></pre></td></tr></table></figure>
<h4 id="1-Category方法列表的装载"><a href="#1-Category方法列表的装载" class="headerlink" title="1. Category方法列表的装载"></a>1. Category方法列表的装载</h4><h5 id="1-1-调用栈"><a href="#1-1-调用栈" class="headerlink" title="1.1 调用栈"></a>1.1 调用栈</h5><p>&emsp;&emsp;我们还是通过runtime的源码来分析这个问题首先看分类的方法是什么时候加到主类的methed_list_t列表中的。下图为调用栈：<img src="/2019/12/05/刨根问底-load方法/image1.png" width="%60" height="%60"><br>&emsp;&emsp;可以看到调用次序是这样的，我们重点看_read_images方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map_images() —&gt;map_images_nolock()—&gt;_read_images()</span><br></pre></td></tr></table></figure>
<h5 id="1-2-read-images（）"><a href="#1-2-read-images（）" class="headerlink" title="1.2 _read_images（）"></a>1.2 _read_images（）</h5><p>&emsp;&emsp;源码较长，这里我只贴对我们有用的部分</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, uint32_t hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//前面的都省略</span></span><br><span class="line"><span class="comment">// Discover categories. </span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">                catlist[i] = <span class="literal">nil</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>, </span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category. </span></span><br><span class="line">            <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">            <span class="comment">// Then, rebuild the class's method lists (etc) if </span></span><br><span class="line">            <span class="comment">// the class is realized. </span></span><br><span class="line">            <span class="keyword">bool</span> classExists = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category -%s(%s) %s"</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category +%s(%s)"</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//后面的也省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意到里面的addUnattachedCategoryForClass方法了吗，OC里面都喜欢这种见文知义的命名方法，直译过来就是为类添加未附加的类别。在这个方法里面，会找到未添加的类别列表对Class和Category做一个映射关联。而在remethodizeClass()方法里面会调用attachCategories把Category中的方法列表加到Class的methed_list_t里面去。而且是插入到Class方法列表的前面（这就是Category中重写主类的方法导致的方法覆盖的原因）</p>
<h4 id="2-load方法的调用"><a href="#2-load方法的调用" class="headerlink" title="2. +load方法的调用"></a>2. +load方法的调用</h4><h5 id="2-1-调用栈"><a href="#2-1-调用栈" class="headerlink" title="2.1 调用栈"></a>2.1 调用栈</h5><p>&emsp;&emsp;我们接着来看+load的方法的调用，如下图所示，<strong>这些会在Category方法装载之后!</strong>下图为调用栈<img src="/2019/12/05/刨根问底-load方法/image2.png" width="%60" height="%60"></p>
<h5 id="2-2-load-images"><a href="#2-2-load-images" class="headerlink" title="2.2 load_images()"></a>2.2 load_images()</h5><p>&emsp;&emsp;load_images()方法会多次调用（每个类都会调用一次）。我们来看load_images()方法的具体内容</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;里面有prepare_load_methods()和call_load_methods()这两个主要方法，先来看第一个</p>
<h5 id="2-3-prepare-load-methods"><a href="#2-3-prepare-load-methods" class="headerlink" title="2.3 prepare_load_methods()"></a>2.3 prepare_load_methods()</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> prepare_load_methods(<span class="keyword">const</span> headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 我是分割线—————————————————————————————————</span></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里面又分两个重要的部分，上面分割线之前是Class中的+load方法加入到对应的list中去，那怎么保证的父类先调用呢</p>
<h5 id="2-3-1-schedule-class-load-amp-add-class-to-loadable-list"><a href="#2-3-1-schedule-class-load-amp-add-class-to-loadable-list" class="headerlink" title="2.3.1 schedule_class_load() &amp; add_class_to_loadable_list()"></a>2.3.1 schedule_class_load() &amp; add_class_to_loadable_list()</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> add_class_to_loadable_list(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往数组中添加loadable_classes结构体，并赋值</span></span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;schedule_class_load()方法做了递归调用一直调用到superclass为空，在schedule_class_load()方法中会调用add_class_to_loadable_list。这样就保证了父类的+load方法是加载到list前面的，从父类到子类依次往数组中添加。执行的时候也是从前往后遍历数组调用。<br>&emsp;&emsp;add_class_to_loadable_list()方法的实现，我们可以很清楚的看到loadable_classes的初始化策略与溢出时的扩容策略。每次需要扩容都会在原来的基础之上*2+16。</p>
<h5 id="2-3-2-add-category-to-loadable-list"><a href="#2-3-2-add-category-to-loadable-list" class="headerlink" title="2.3.2 add_category_to_loadable_list()"></a>2.3.2 add_category_to_loadable_list()</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> add_category_to_loadable_list(Category cat)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = _category_getLoadMethod(cat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't bother if cat has no +load method</span></span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: category '%s(%s)' scheduled for +load"</span>, </span><br><span class="line">                     _category_getClassName(cat), _category_getName(cat));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_categories_used == loadable_categories_allocated) &#123;</span><br><span class="line">        loadable_categories_allocated = loadable_categories_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_categories = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">            realloc(loadable_categories,</span><br><span class="line">                              loadable_categories_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//往数组中添加loadable_categories结构体，并赋值</span></span><br><span class="line">    loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">    loadable_categories[loadable_categories_used].method = method;</span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来看分割线之后的部分，在Class的+load方法处理完成时候才会来处理Category中的+load方法，这里用到了add_category_to_loadable_list()可以看到与add_class_to_loadable_list()方法的内容基本一样只是标志位和数组的名字不同而已。add_category_to_loadable_list()在Category中的+load方法加入到对应的列表中。至此prepare_load_methods()方法执行完毕。</p>
<h4 id="2-4-call-load-methods"><a href="#2-4-call-load-methods" class="headerlink" title="2.4 call_load_methods()"></a>2.4 call_load_methods()</h4><p>&emsp;&emsp;接下来我们来看call_load_methods()方法的具体内容</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;看代码这里还用到了aotureleasePool，这个是题外话了，撇开不谈。我们来看今天的重点，首先是一个do while循环，循环条件有两个。第一个loadable_classes_used（查看文章开头），第二个是call_category_loads()方法的返回值，这个返回值是什么呢，其实就是loadable_categories_used&gt;0。在这里先后调用所有Class列表中的+load方法，Category列表中的+load方法call_class_loads()和call_category_loads()两个方法的代码我就不贴了。代码有点多，影响阅读，有兴趣可以去看runtime的源码。</p>
<h4 id="3-总结与问题"><a href="#3-总结与问题" class="headerlink" title="3. 总结与问题"></a>3. 总结与问题</h4><h5 id="3-1总结"><a href="#3-1总结" class="headerlink" title="3.1总结"></a>3.1总结</h5><p>&emsp;&emsp;分析下来，基本回答了文章开头所述的+load方法特征的原因。总结如下：<br>&emsp;&emsp;1、Category方法列表的装载是在_read_images的时候发生的，这个调用比较早在map_images之后，load_images前。<br>&emsp;&emsp;2、+load方法的调用是在load_images是发生的，而且load_image会重复调用（每个类都会调用）。而load_images调在_read_images之后，也就是说是在Category中的方法插入到Class中的方法列表之后调用的。<br>&emsp;&emsp;3、+load方法的调用是又专门的方法负责的，Class和Category分别有一个数组保存+load方法（数组内保存的是loadable_class，和loadable_category结构体参考文章开头的介绍）。所以不会被Category方法的装载导致方法覆盖。<br>&emsp;&emsp;4、Class的数组，加入的次序也是有保证的，从最高级的父类到子类一次加入，调用的时候能保证先父类后子类。<br>&emsp;&emsp;5、Category数组，调用是在Class中的方法列表调用完成之后，保证了次序。</p>
<h5 id="3-2问题"><a href="#3-2问题" class="headerlink" title="3.2问题"></a>3.2问题</h5><p> &emsp;&emsp;call_class_loads()的实现比较简单，就是一个for循环依次调用+load。call_category_loads()内部的实现就复杂了不少，还有许多复杂的代码，笔者也是没有太看懂内部的那些判断和循环，也不敢在这里误人子弟。如果有哪位明白的请不吝指教。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[加快Xcode的编译速度]]></title>
      <url>http://nanshanyi.github.io/2017/05/12/%E5%8A%A0%E5%BF%ABXcode%E7%9A%84%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>　　不知道大家有没有经历过，公司给配个mac，最低配，没有ssd，Cpu1.4GHz。全量编译一次一二十分钟，增量编译也要至少三分钟，尤其是在调UI的时候。真的是能捉急死人！<br>　　搜罗各地找到一个比较实用的加快编译的方法。<br><a id="more"></a></p>
<h5 id="1-前提与原理"><a href="#1-前提与原理" class="headerlink" title="1.前提与原理"></a>1.前提与原理</h5><p>　　内存16G以上，小于此标准的请恕我也无能为力。<br>　　此方法主要是利用RAM（内存）来创建一个虚拟的磁盘，用来存放编译文件。大家都知道，RAM的速度是ROM（存储器）的几十到几百倍不等，利用RAM可以加速文件读写。</p>
<h5 id="2-创建脚本文件"><a href="#2-创建脚本文件" class="headerlink" title="2.创建脚本文件"></a>2.创建脚本文件</h5><p>　　可以使用Sublime(文件类型请选择Shell Script(Bash))或者终端vi编辑器（不会的自行学习），在桌面创建一个文件，文件名ramdisk.sh（名字可以自定，后缀不能改）<br>　　写入以下脚本代码保存：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">RAMDISK=<span class="string">"ramdisk"</span></span><br><span class="line">SIZE=4096 <span class="comment">#4GB, size in MB for ramdisk.</span></span><br><span class="line">diskutil erasevolume HFS+ <span class="variable">$RAMDISK</span> `hdiutil attach -nomount ram://$[SIZE*2048]`</span><br></pre></td></tr></table></figure>
<h5 id="2-执行脚本文件"><a href="#2-执行脚本文件" class="headerlink" title="2.执行脚本文件"></a>2.执行脚本文件</h5><p>　　首先需要给文件添加可执行权限，终端cd到ramdisk.sh文件统计目录下（此处就是桌面），终端执行一下命令给文件添加可执行权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./ramdisk.sh</span><br></pre></td></tr></table></figure></p>
<p>　　然后终端输入以下命令执行文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ramdisk.sh</span><br></pre></td></tr></table></figure></p>
<p>　　你会发现桌面上多了一个磁盘如下图所示<br><img src="/2017/05/12/加快Xcode的编译速度/image1.png" width="%60" height="%60"></p>
<h5 id="3-修改Xcode的配置"><a href="#3-修改Xcode的配置" class="headerlink" title="3.修改Xcode的配置"></a>3.修改Xcode的配置</h5><p>　　Xcode -&gt; Preferences -&gt; Locations<br>　　Derived Data  (Custom): /Volumes/ramdisk/DeriveData<br><img src="/2017/05/12/加快Xcode的编译速度/image2.png" width="%60" height="%60"><br>　　点击Advanced…选以下点击Done<br><img src="/2017/05/12/加快Xcode的编译速度/image3.png" width="%60" height="%60"><br>　　之后就可以进行编译了，有没有发现快了一点呢？</p>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h5><p>　　试过之后，确实是要快一点的，尤其是对全量编译而言，能提升不少速度。<br>　　问题：<br>　　1、4GB的大小勉强够用，可能在编译几十次之后会出现空间不足的情况，这时候可以把ramdisk里面DriveData下面的文件删除，重新编译（当然你也可以给的空间大一点）。<br>　　2、由于内存只是暂存，重启之后ramdisk的磁盘会消失，需要重新跑一次脚本，重新生成。<br>　　以上方法仅为权宜之计，最好的解决办法就是换一台带SSD的配置好一点的mac。如果你的mac配置本来就很好，是因为你的项目实在太大，那就需要另寻他法了，比如说：使用模块化方案，每一块分成一个静态包，这样每次只编译打开的部分代码，这样可以提高编译速度（这就涉及太广了，有兴趣可以自行学习）。</p>
]]></content>
      
        
        <tags>
            
            <tag> Xcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[封装一个匹配特定字符可点击的Label]]></title>
      <url>http://nanshanyi.github.io/2016/09/10/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E5%8F%AF%E7%82%B9%E5%87%BB%E7%9A%84Label/</url>
      <content type="html"><![CDATA[<p>这个功能用的最多的就是在微博里面，里面有用户名@南山忆，网址<a href="http://www.jianshu.com/users/774b1d5616a7/latest_articles，#话题#" target="_blank" rel="noopener">http://www.jianshu.com/users/774b1d5616a7/latest_articles，#话题#</a> 等需要特别现实，还需要有点击事件，这种情况下普通的label显示已经满足不了需求了。需要我们来自己写一个可实现相应功能的label。<br>　　好了废话不多说，让我们开始，大致流程如下：<br><img src="/2016/09/10/封装一个匹配特定字符可点击的Label/966908-f27bbdadc93c7346.png" width="%60" height="%60"><br><a id="more"></a></p>
<h5 id="主要用到的属性"><a href="#主要用到的属性" class="headerlink" title="主要用到的属性"></a>主要用到的属性</h5><p>textStorage，layoutManager，textContainer的关系<br>1）NSTextStorage是NSMutableAttributedString的子类，由于可以灵活地往文字添加或修改属性，所以非常适用于保存并修改文字属性。<br>2）NSLayoutManager用来管理NSTextStorage其中的文字内容的排版布局。<br>3）NSTextContainer定义了一个矩形区域用于存放已经进行了排版并设置好属性的文字<br>三者关系如图所示<br><img src="/2016/09/10/封装一个匹配特定字符可点击的Label/966908-c7bbb6aa396eac57.png" width="%60" height="%60"></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是NSMutableAttributedString的子类，由于可以灵活地往文字添加或修改属性，所以非常适用于保存并修改文字属性。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTextStorage</span> *textStorage;</span><br><span class="line"><span class="comment">//管理NSTextStorage其中的文字内容的排版布局。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSLayoutManager</span> *layoutManager;</span><br><span class="line"><span class="comment">//定义了一个矩形区域用于存放已经进行了排版并设置好属性的文字</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTextContainer</span> *textContainer;</span><br></pre></td></tr></table></figure>
<p>需要重写系统方法，这里讲主要的<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">       <span class="comment">//准备文本</span></span><br><span class="line">        [<span class="keyword">self</span> prepareTextSystem];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置容器大小为label的尺寸</span></span><br><span class="line">- (<span class="keyword">void</span>)layoutSubviews&#123;</span><br><span class="line">    <span class="keyword">self</span>.textContainer.size = <span class="keyword">self</span>.frame.size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写drawTextInRect方法绘制背景，文字</span></span><br><span class="line">- (<span class="keyword">void</span>)drawTextInRect:(<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">    <span class="comment">//如果有选中的range，改变文字背景颜色。</span></span><br><span class="line">    <span class="keyword">if</span> (_selectedRangeValue) &#123;</span><br><span class="line">        <span class="built_in">UIColor</span> *selectColor = _isSelected ? [<span class="built_in">UIColor</span> colorWithWhite:<span class="number">0.6</span> alpha:<span class="number">0.2</span>] : [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">        <span class="comment">//设置文字背景颜色</span></span><br><span class="line">        [<span class="keyword">self</span>.textStorage addAttribute:<span class="built_in">NSBackgroundColorAttributeName</span> value:selectColor range:<span class="keyword">self</span>.selectedRangeValue.rangeValue];</span><br><span class="line">        <span class="comment">//绘制背景颜色</span></span><br><span class="line">        [<span class="keyword">self</span>.layoutManager drawBackgroundForGlyphRange:<span class="keyword">self</span>.selectedRangeValue.rangeValue atPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="keyword">self</span>.textStorage.length);</span><br><span class="line">    [<span class="keyword">self</span>.layoutManager drawGlyphsForGlyphRange:range atPoint:<span class="built_in">CGPointZero</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="准备文本显示"><a href="#准备文本显示" class="headerlink" title="准备文本显示"></a>准备文本显示</h5><p>　　这里面会用到正则表达式，正则表达式是一门挺深的学问。有不太了解的童鞋可以参考<br>&lt;a href=”<a href="http://deerchao.net/tutorials/regex/regex-1.htm&quot;target=&quot;_blank&quot;&gt;这篇文章" target="_blank" rel="noopener">http://deerchao.net/tutorials/regex/regex-1.htm&quot;target=&quot;_blank&quot;&gt;这篇文章</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)prepareTextSystem &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将布局添加到storage</span></span><br><span class="line">    [<span class="keyword">self</span>.textStorage addLayoutManager:<span class="keyword">self</span>.layoutManager];</span><br><span class="line">    <span class="comment">//将容器添加到布局中</span></span><br><span class="line">    [<span class="keyword">self</span>.layoutManager addTextContainer:<span class="keyword">self</span>.textContainer];</span><br><span class="line">    <span class="keyword">self</span>.userInteractionEnabled = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">//设置左右边距</span></span><br><span class="line">    <span class="keyword">self</span>.textContainer.lineFragmentPadding = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)prepareText&#123;</span><br><span class="line">    <span class="built_in">NSAttributedString</span> *attrString;</span><br><span class="line"><span class="comment">//拿到文本，或者富文本，拿不到置为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.attributedText) &#123;</span><br><span class="line">        attrString = <span class="keyword">self</span>.attributedText;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.text)&#123;</span><br><span class="line">        attrString = [[<span class="built_in">NSAttributedString</span> alloc]initWithString:<span class="keyword">self</span>.text];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        attrString = [[<span class="built_in">NSAttributedString</span> alloc]initWithString:<span class="string">@""</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.selectedRangeValue = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//设置折行模式</span></span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *attrMString = [<span class="keyword">self</span> addLineBreak:attrString];</span><br><span class="line">    [<span class="keyword">self</span>.textStorage setAttributedString:attrMString];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正则匹配，匹配我们需要的@XXX和URL</span></span><br><span class="line">     <span class="keyword">self</span>.linkRanges = [<span class="keyword">self</span> getRanges:<span class="string">@"http(s)?://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?"</span>];</span><br><span class="line">    <span class="built_in">UIColor</span> *attrColor = _attrStrColor == <span class="literal">nil</span> ? [<span class="built_in">UIColor</span> blueColor] : _attrStrColor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSValue</span> *rangeValue <span class="keyword">in</span> <span class="keyword">self</span>.linkRanges) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.textStorage addAttribute:<span class="built_in">NSForegroundColorAttributeName</span> value:attrColor range:rangeValue.rangeValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.userRanges = [<span class="keyword">self</span> getRanges:<span class="string">@"@\\w&#123;1,&#125;?:"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSValue</span> *rangeValue <span class="keyword">in</span> <span class="keyword">self</span>.userRanges) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.textStorage addAttribute:<span class="built_in">NSForegroundColorAttributeName</span> value:attrColor range:rangeValue.rangeValue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匹配完成调用setNeedsDisplay，来触发drawTextInRect绘制文字</span></span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加折行模式</span></span><br><span class="line">- (<span class="built_in">NSMutableAttributedString</span>*)addLineBreak:(<span class="built_in">NSAttributedString</span> *) attrString&#123;</span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *attrMString = [[<span class="built_in">NSMutableAttributedString</span> alloc]initWithAttributedString:attrString];</span><br><span class="line">    <span class="keyword">if</span> (attrMString.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attrMString;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = (<span class="built_in">NSMutableDictionary</span>*)[attrMString attributesAtIndex:<span class="number">0</span> effectiveRange:&amp;range];</span><br><span class="line">    <span class="comment">//里面有NSShadow,NSParagraphStyle,NSFont,NSColor四个值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,dict);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableParagraphStyle</span> *paragraphStyle = [dict[<span class="built_in">NSParagraphStyleAttributeName</span>] mutableCopy] ;</span><br><span class="line">    <span class="comment">//设置paragraphStyle，如果不为空，则设置折行模式,为空则自己生成并add</span></span><br><span class="line">    <span class="keyword">if</span> (paragraphStyle) &#123;</span><br><span class="line">        paragraphStyle.lineBreakMode = <span class="built_in">NSLineBreakByCharWrapping</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        paragraphStyle = [[<span class="built_in">NSMutableParagraphStyle</span> alloc]init];</span><br><span class="line">        paragraphStyle.lineBreakMode = <span class="built_in">NSLineBreakByCharWrapping</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [attrMString addAttribute:<span class="built_in">NSParagraphStyleAttributeName</span> value:paragraphStyle range:range];</span><br><span class="line">    <span class="keyword">return</span> attrMString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="正则的匹配"><a href="#正则的匹配" class="headerlink" title="正则的匹配"></a>正则的匹配</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *)getRanges:(<span class="built_in">NSString</span>*)pattern&#123;</span><br><span class="line">    <span class="comment">//生成匹配规则</span></span><br><span class="line">    <span class="built_in">NSRegularExpression</span> *regular = [[<span class="built_in">NSRegularExpression</span> alloc]initWithPattern:pattern options:<span class="built_in">NSRegularExpressionCaseInsensitive</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//根据匹配规则匹配相应的文字</span></span><br><span class="line">    <span class="built_in">NSArray</span> *results = [regular matchesInString:<span class="keyword">self</span>.textStorage.string options:<span class="built_in">NSMatchingReportCompletion</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="keyword">self</span>.textStorage.string.length)];</span><br><span class="line"><span class="comment">//由于OC的数组只能放对象，NSRange是不能放进去的，所以在此转换为NSValue来放入数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *ranges = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSTextCheckingResult</span> *result <span class="keyword">in</span> results) &#123;</span><br><span class="line">        <span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithRange:result.range];</span><br><span class="line">        [ranges addObject:value];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ranges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="点击交互处理"><a href="#点击交互处理" class="headerlink" title="点击交互处理"></a>点击交互处理</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">  <span class="comment">//记录是否有选中</span></span><br><span class="line">    _isSelected = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//拿到touch的位置</span></span><br><span class="line">    <span class="built_in">CGPoint</span> selectPoint = [[touches anyObject] locationInView:<span class="keyword">self</span>];</span><br><span class="line"><span class="comment">//获取touch的位置在那个range范围内，拿到selectedRange</span></span><br><span class="line">    <span class="keyword">self</span>.selectedRangeValue = [<span class="keyword">self</span> getSelectRange:selectPoint];</span><br><span class="line">    <span class="keyword">if</span> (!_selectedRangeValue) &#123;</span><br><span class="line">        [<span class="keyword">super</span> touchesBegan:touches withEvent:event];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_selectedRangeValue) &#123;</span><br><span class="line">        [<span class="keyword">super</span> touchesEnded:touches withEvent:event];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//是否有选中置为NO</span></span><br><span class="line">    _isSelected = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">//更新label显示</span></span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line"><span class="comment">//回调Block触发相应的事件</span></span><br><span class="line">    <span class="built_in">NSString</span> *contentText = [<span class="keyword">self</span>.textStorage.string substringWithRange:_selectedRangeValue.rangeValue];</span><br><span class="line">    <span class="keyword">switch</span> (_tapHandleType) &#123;</span><br><span class="line">        <span class="keyword">case</span> TapHandleUser:</span><br><span class="line">            <span class="keyword">if</span> (_userTaphandle) &#123;</span><br><span class="line">            _userTaphandle(<span class="keyword">self</span>,contentText,_selectedRangeValue.rangeValue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TapHandlelink:</span><br><span class="line">            <span class="keyword">if</span> (_linkTapHandle) &#123;</span><br><span class="line">             _linkTapHandle(<span class="keyword">self</span>,contentText,_selectedRangeValue.rangeValue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取点击位置在哪个range范围内</span></span><br><span class="line">-(<span class="built_in">NSValue</span>*)getSelectRange:(<span class="built_in">CGPoint</span>)selectPoint&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.textStorage.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据电机的位置得到点击的是label内的第几个字符索引</span></span><br><span class="line">    <span class="built_in">NSInteger</span> index = [<span class="keyword">self</span>.layoutManager glyphIndexForPoint:selectPoint inTextContainer:<span class="keyword">self</span>.textContainer];</span><br><span class="line"><span class="comment">//遍历所有range,确定index在哪个range范围内</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSValue</span> *rangeValue <span class="keyword">in</span> <span class="keyword">self</span>.linkRanges) &#123;</span><br><span class="line">        <span class="built_in">NSRange</span> range = rangeValue.rangeValue;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= range.location &amp;&amp; index &lt;range.location + range.length) &#123;</span><br><span class="line"><span class="comment">//一旦遍历到就记录点击的范围类型，调用setNeedsDisplay触发文字label重新绘制</span></span><br><span class="line">            _tapHandleType = TapHandlelink;</span><br><span class="line">            [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line"><span class="comment">//返回range范围</span></span><br><span class="line">            <span class="keyword">return</span> rangeValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSValue</span> *rangeValue <span class="keyword">in</span> <span class="keyword">self</span>.userRanges) &#123;</span><br><span class="line">        <span class="built_in">NSRange</span> range = rangeValue.rangeValue;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= range.location &amp;&amp; index &lt;range.location + range.length) &#123;</span><br><span class="line">            _tapHandleType = TapHandleUser;</span><br><span class="line">            [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">            <span class="keyword">return</span> rangeValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _tapHandleType = TapHandleNone;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>　　1、这里面主要用到了三个重要的属性：NSTextStorage、NSLayoutManager、NSTextContainer要高明白其中的关系。上面有图介绍。<br>　　2、正则表达式的使用，现在基本上大部分语言都支持正则，里面的学问很多，需要多加学习。<br>　　3、点击事件的处理。<br>这是&lt;a href=”<a href="https://github.com/nanshanyi/GHLabel&quot;target=&quot;_blank&quot;&gt;GitHub地址" target="_blank" rel="noopener">https://github.com/nanshanyi/GHLabel&quot;target=&quot;_blank&quot;&gt;GitHub地址</a>可以在此查看源码。本文为原创，如需转载请注明出处。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NSString的Copy与Strong你用对了吗？]]></title>
      <url>http://nanshanyi.github.io/2016/08/12/NSString%E7%9A%84Copy%E4%B8%8EStrong%E4%BD%A0%E7%94%A8%E5%AF%B9%E4%BA%86%E5%90%97%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>NSString我们必不可少的类,但是在你@property的时候，到底是用Strong，还是Copy修饰。你用对了吗？</p>
<h5 id="用例子来说明一下"><a href="#用例子来说明一下" class="headerlink" title="用例子来说明一下"></a>用例子来说明一下</h5><h6 id="先使用NSString"><a href="#先使用NSString" class="headerlink" title="先使用NSString"></a>先使用NSString</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *strongStr;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,   <span class="keyword">copy</span>) <span class="built_in">NSString</span> *copyedStr;</span><br><span class="line"><span class="comment">//不可以写成copyStr会报property follows cocoa naming convention for returning 'owned' objects</span></span><br><span class="line"><span class="comment">//意思是不能使用copy来作为开头命名，copy是cocoa用的</span></span><br></pre></td></tr></table></figure>
<p>　　这里声明了两个NSString变量，一个用strong修饰，另一个用copy来修饰，下面我们来用一个NSString对两个string赋值。<br><a id="more"></a></p>
<h6 id="输出查看一下结果"><a href="#输出查看一下结果" class="headerlink" title="输出查看一下结果"></a>输出查看一下结果</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> *testStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"nanshanyi"</span>];</span><br><span class="line">    <span class="keyword">self</span>.strongStr = testStr;</span><br><span class="line">    <span class="keyword">self</span>.copyedStr = testStr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testStr:   %p, %p"</span>,testStr,&amp;testStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"strongStr: %p, %p"</span>,_strongStr,&amp;_strongStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"copyedStr: %p, %p"</span>,_copyedStr,&amp;_copyedStr);</span><br><span class="line"><span class="comment">//前面的是内存地址，后面的是指针地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testStr:   <span class="number">0xa01c06542cac2d0a</span>, <span class="number">0x16fdb1f48</span></span><br><span class="line">strongStr: <span class="number">0xa01c06542cac2d0a</span>, <span class="number">0x1346e6030</span></span><br><span class="line">copyedStr: <span class="number">0xa01c06542cac2d0a</span>, <span class="number">0x1346e6038</span></span><br></pre></td></tr></table></figure>
<p>　　根据输出的内存地址，我们发现，不管用的是strong还是copy，指向的都是同一个地址，也就是testStr的地址。strongStr和copyedStr都只是对testStr的引用，只会导致testStr的计数器加1，并没有拷贝一份新的，testStr的retainCount应该是3。</p>
<h6 id="下面我们改用NSMutableString"><a href="#下面我们改用NSMutableString" class="headerlink" title="下面我们改用NSMutableString"></a>下面我们改用NSMutableString</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSMutableString</span> *testStr = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"nanshanyi"</span>];</span><br><span class="line">    <span class="keyword">self</span>.strongStr = testStr;</span><br><span class="line">    <span class="keyword">self</span>.copyedStr = testStr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testStr:   %p, %p"</span>,testStr,&amp;testStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"strongStr: %p, %p"</span>,_strongStr,&amp;_strongStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"copyedStr: %p, %p"</span>,_copyedStr,&amp;_copyedStr);</span><br><span class="line"></span><br><span class="line">    [testStr appendString:<span class="string">@"123"</span>];<span class="comment">//修改一下</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testStr:   %@, %p"</span>,testStr,&amp;testStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"strongStr: %@, %p"</span>,_strongStr,&amp;_strongStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"copyedStr: %@, %p"</span>,_copyedStr,&amp;_copyedStr);</span><br></pre></td></tr></table></figure>
<p>　　我们再来看一下结果：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">testStr:   <span class="number">0x15cdf87f0</span>, <span class="number">0x16fd99f48</span></span><br><span class="line">strongStr: <span class="number">0x15cdf87f0</span>, <span class="number">0x15cdf3ad0</span></span><br><span class="line">copyedStr: <span class="number">0xa0b20b31520b9419</span>, <span class="number">0x15cdf3ad8</span></span><br><span class="line"><span class="comment">//修改后输出一下字符串内容</span></span><br><span class="line">testStr:   nanshanyi123, <span class="number">0x16fd99f48</span></span><br><span class="line">strongStr: nanshanyi123, <span class="number">0x15cdf3ad0</span></span><br><span class="line">copyedStr: nanshanyi, <span class="number">0x15cdf3ad8</span></span><br></pre></td></tr></table></figure></p>
<p>　　可以看到这个时候，copy修饰的copyedStr字符串，已经不再是简单的引用了，而是拷贝了一个新的，让copyedStr指向了这个新的地址。此时testStr的retainCount应该是2。<br>　　然后我们把testStr修改一下，后面接上了“123”，输出内容会发现testStr变化后，strongStr会随之改变。而copyStr则不会随之变化。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>　　由上面的例子可以得出：当原字符串是NSString时，由于是不可变字符串，所以，不管是使用strong还是copy修饰，都是指向原来的对象，copy操作只是做了次<strong>浅拷贝</strong>。<br>　　而当源字符串是NSMutableString时，strong只是将原字符串的引用计数加1，而copy<br>则是对原字符串做了次<strong>深拷贝</strong>，从而生成了一个新的对象，并且copy的对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString，而不是NSMutableString，如果想让拷贝过来的对象是可变的，就需要使mutableCopy。<br>　　所以，如果原字符串是NSMutableString的时候，使用strong只会增加引用计数器。但是copy会执行一次<strong>深拷贝</strong>，会造成不必要的内存浪费。而如果原字符串是NSString时，copy和strong效果一样，就不会有这个问题。<br>　　但是，一般我们声明NSString时，也不会希望它改变，所以一般情况下，建议用copy，这样可以避免NSMutableString带来的奇葩错误。</p>
<h5 id="顺便提一下assign与weak"><a href="#顺便提一下assign与weak" class="headerlink" title="顺便提一下assign与weak"></a>顺便提一下assign与weak</h5><p>　　我们都知道，assign用来修饰基本数据类型，weak用来修饰OC对象。<br>　　其实照理说assign也可以用来修饰对象。但是assign修饰的对象在此对象释放的时候，指针地址依然存在，不会被置为nil，这就会造成很严重的问题，也就是会产生野指针。但是用weak来修饰的话在对象释放的时候会把指针置为nil，从而避免野指针的出现。<br>　　那你又会问了，那凭啥基本数据类型就可以使用assign。这个就又要扯到堆和栈的问题了，基本数据类型一般是被分配到栈空间。而栈是由系统自动管理分配和释放。就不会造成野指针的问题。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[研究一下陀螺仪和加速度计]]></title>
      <url>http://nanshanyi.github.io/2016/07/18/%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E9%99%80%E8%9E%BA%E4%BB%AA%E5%92%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h5 id="先来看一下效果"><a href="#先来看一下效果" class="headerlink" title="先来看一下效果"></a>先来看一下效果</h5><p><img src="/2016/07/18/研究一下陀螺仪和加速度计/motion.gif" width="40%" height="40%"><br>这是通过调用iOS的陀螺仪和加速度计。通过倾斜手机实现的效果</p>
<h5 id="Core-Motion"><a href="#Core-Motion" class="headerlink" title="Core Motion"></a>Core Motion</h5><p> 　　加速度计和陀螺仪是通过Core Motion框架，来管理访问的。此框架提供了CMMotionManager类，它提供的数据都是用来描述设备的移动的。还提供了CMAccelerometerData和CMGroData，他们可以访问原生的加速度计和陀螺仪信息。另外还有CMDeviceMotion，这个类里面包含有加速度计和陀螺仪的测量数据，以及方位信息。即设备是平放，朝上，朝下，还是朝左等信息。话不多说还是直接上代码。<br> 　　先来个坐标系作为参考<br> <img src="/2016/07/18/研究一下陀螺仪和加速度计/xyz.png" width="40%" height="40%"><br><a id="more"></a></p>
<h5 id="看一下各项数据"><a href="#看一下各项数据" class="headerlink" title="看一下各项数据"></a>看一下各项数据</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kUpdateInterval (1.f / 60.f)<span class="comment">//定义一个更新时间</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">CMMotionManager</span> *motionManager;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSOperationQueue</span> *quene;</span><br><span class="line"><span class="comment">//声明一个线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.motionManager = [[<span class="built_in">CMMotionManager</span> alloc]init];</span><br><span class="line"><span class="built_in">NSOperationQueue</span> *quene = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">初始化一个线程，动作管理器需要一个单独的线程来运行，以便在每次发生事件时放入要执行的工作。苹果文档之处不要放在默认队列，可能会被事件填满，无法处理别的事件</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.motionManager.deviceMotionAvailable) &#123;</span><br><span class="line">        <span class="keyword">self</span>.motionManager.deviceMotionUpdateInterval = <span class="number">0.1</span>;</span><br><span class="line">        <span class="comment">//设置更新数据的时间间隔</span></span><br><span class="line">        [<span class="keyword">self</span>.motionManager startDeviceMotionUpdatesToQueue: quene withHandler:^(<span class="built_in">CMDeviceMotion</span> * _Nullable motion, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">            <span class="built_in">CMRotationRate</span> rotationRate = motion.rotationRate;</span><br><span class="line">           <span class="comment">//旋转速率对应x，y，z分别是设备绕x，y，z 轴（上面有图参考）</span></span><br><span class="line">           的旋转速率，顺时针为正，逆时针为负</span><br><span class="line">            <span class="built_in">CMAcceleration</span> gravity = motion.gravity;</span><br><span class="line">            <span class="comment">//自然加速度，可是识别手机的放置方向，设备平放在桌上，z=-1;</span></span><br><span class="line">               屏幕朝左侧立，x = <span class="number">-1</span>；充电口朝下垂直放置，y=<span class="number">-1</span></span><br><span class="line">            <span class="built_in">CMAcceleration</span> userAcc = motion.userAcceleration;</span><br><span class="line">            <span class="comment">//用户运动手机造成的加速度，分别向xyz方向运动时，正向时即为正值</span></span><br><span class="line">            <span class="built_in">CMAttitude</span> *attitude = motion.attitude;</span><br><span class="line">            <span class="comment">//设备的旋转程度，也可以理解为设备绕xyz轴旋转的程度，单位是</span></span><br><span class="line">            弧度，即旋转一周的值为<span class="number">2</span>π，手机绕举个例子：把手机平放在桌面上，</span><br><span class="line">            旋转手机Yaw(偏移)开始变化，旋转<span class="number">180</span>°时yaw = <span class="number">3.14</span>;</span><br><span class="line">            绕Y轴旋转时Roll变化；绕X轴旋转时Pitch变化（方向不在多做讨论，参考系不一样，没法统一）</span><br><span class="line">            <span class="built_in">NSString</span> *gyroscopeText = [<span class="built_in">NSString</span>   stringWithFormat:<span class="string">@"Rotation:\\n x = %.2f\\n y = %.2f\\n</span></span><br><span class="line"><span class="string">  z = %.2f"</span>,rotationRate.x,rotationRate.y,rotationRate.z];</span><br><span class="line">            <span class="built_in">NSString</span> *acceleratiorText = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Accelertion: \\n Gravity x = %.2f\\tUser x = %.2f</span></span><br><span class="line"><span class="string">\\n Gravity y = %.2f\\tUser y = %.2f \\n Gravity z = %.2f\\tUser z = %.2f \\n"</span>,gravity.x,userAcc.x,gravity.y,userAcc.y,gravity.z,userAcc.z];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSString</span> *attitudeText = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Attitute:\\n Roll = %.2f\\nPitch = %.2f</span></span><br><span class="line"><span class="string">\\nYaw = %.2f\\n"</span>,attitude.roll,attitude.pitch,attitude.yaw];</span><br><span class="line"><span class="comment">//            NSLog(@"%@",gyroscopeText);</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                _gyroscopeLabel.text = gyroscopeText;</span><br><span class="line">                _accelerometerLabel.text = acceleratiorText;</span><br><span class="line">                _attitudeLabel.text = attitudeText;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="然后我们来做一个Demo"><a href="#然后我们来做一个Demo" class="headerlink" title="然后我们来做一个Demo"></a>然后我们来做一个Demo</h5><p>  controller中代码实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kUpdateInterval (1.f / 60.f)<span class="comment">//更新频率高一点</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BallViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">CMMotionManager</span> *motionManager;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSOperationQueue</span> *quene;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    BallView *ballView = [[BallView alloc]initWithFrame:<span class="keyword">self</span>.view.bounds];</span><br><span class="line"><span class="comment">//自己写的类继承自UIView</span></span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:ballView];</span><br><span class="line">    <span class="keyword">self</span>.motionManager = [[<span class="built_in">CMMotionManager</span> alloc]init];</span><br><span class="line">    <span class="keyword">self</span>.quene = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">    <span class="keyword">self</span>.motionManager.deviceMotionUpdateInterval = kUpdateInterval;</span><br><span class="line">    [<span class="keyword">self</span>.motionManager startDeviceMotionUpdatesToQueue:_quene withHandler:^(<span class="built_in">CMDeviceMotion</span> * _Nullable motion, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line"><span class="comment">//此处也可以传入motion.userAcceleration。（用户移动手机产生的加速度）这样就可以实现摇动来控制（ballView里面的放大倍数记得要改大一点）</span></span><br><span class="line">        [ballView setAcceleration:motion.gravity];</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [ballView update];</span><br><span class="line">       <span class="comment">//主线程更新UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BallView的实现<br>.h文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;CoreMotion/CoreMotion.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BallView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)<span class="built_in">CMAcceleration</span> acceleration;</span><br><span class="line">- (<span class="keyword">void</span>)update;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>.m文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BallView</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)<span class="built_in">CGFloat</span> width;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)<span class="built_in">CGFloat</span> height;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)<span class="built_in">CGFloat</span> imageWidth;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)<span class="built_in">CGFloat</span> imageHeight;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">UIImage</span> *image;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">UIImageView</span> *imageView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)<span class="built_in">CGPoint</span> currentPoint;<span class="comment">//当前ImageView位置</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)<span class="built_in">CGFloat</span> ballXVelocity;<span class="comment">//X方向速度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)<span class="built_in">CGFloat</span> ballYVelocity;<span class="comment">//Y方向速度</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BallView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> commoninit];</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)commoninit&#123;</span><br><span class="line">    <span class="keyword">self</span>.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"btn_nav04@3x"</span>];</span><br><span class="line">    <span class="keyword">self</span>.imageView = [[<span class="built_in">UIImageView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.imageWidth, <span class="keyword">self</span>.imageHeight)];</span><br><span class="line">    <span class="keyword">self</span>.imageView.image = _image;</span><br><span class="line">    [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.imageView];</span><br><span class="line">    <span class="keyword">self</span>.currentPoint = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.bounds.size.width/<span class="number">2.</span>f+<span class="keyword">self</span>.image.size.width/<span class="number">2.</span>f, <span class="keyword">self</span>.bounds.size.height/<span class="number">2.</span>f+<span class="keyword">self</span>.image.size.height/<span class="number">2.</span>f);</span><br><span class="line">    <span class="keyword">self</span>.imageView.center = _currentPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCurrentPoint:(<span class="built_in">CGPoint</span>)newPoint&#123;</span><br><span class="line">    _currentPoint = newPoint;</span><br><span class="line">        <span class="comment">//边缘判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.currentPoint.x &lt;= <span class="keyword">self</span>.imageWidth/<span class="number">2.</span>f) &#123;</span><br><span class="line">        _currentPoint.x = <span class="keyword">self</span>.imageWidth/<span class="number">2.</span>f;</span><br><span class="line">        <span class="keyword">self</span>.ballXVelocity = -_ballXVelocity/<span class="number">2.</span>f;</span><br><span class="line">        <span class="comment">//反弹效果，接触边缘后加速度反向减半</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.currentPoint.y &lt;= <span class="keyword">self</span>.imageHeight/<span class="number">2.</span>f) &#123;</span><br><span class="line">        _currentPoint.y = <span class="keyword">self</span>.imageHeight/<span class="number">2.</span>f;</span><br><span class="line">        <span class="keyword">self</span>.ballYVelocity = -_ballYVelocity/<span class="number">2.</span>f;</span><br><span class="line">        <span class="comment">//反弹效果，接触边缘后加速度反向减半</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.currentPoint.x &gt;= <span class="keyword">self</span>.width -<span class="keyword">self</span>.imageWidth/<span class="number">2.</span>f ) &#123;</span><br><span class="line">        _currentPoint.x = <span class="keyword">self</span>.width -<span class="keyword">self</span>.imageWidth/<span class="number">2.</span>f;</span><br><span class="line">        <span class="keyword">self</span>.ballXVelocity = -_ballXVelocity/<span class="number">2.</span>f;</span><br><span class="line">        <span class="comment">//反弹效果，接触边缘后加速度反向减半</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.currentPoint.y &gt;= <span class="keyword">self</span>.height -<span class="keyword">self</span>.imageHeight/<span class="number">2.</span>f ) &#123;</span><br><span class="line">        _currentPoint.y = <span class="keyword">self</span>.height -<span class="keyword">self</span>.imageHeight/<span class="number">2.</span>f;</span><br><span class="line">        <span class="keyword">self</span>.ballYVelocity = -_ballYVelocity/<span class="number">2.</span>f;</span><br><span class="line">       <span class="comment">//反弹效果，接触边缘后加速度反向减半</span></span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> updateCenter];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)updateCenter&#123;</span><br><span class="line">    <span class="keyword">self</span>.imageView.center = _currentPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)update&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDate</span> *lastUpdateTime = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastUpdateTime != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSTimeInterval</span> secondsSinceLastDraw = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:lastUpdateTime];<span class="comment">//两次更新的时间差</span></span><br><span class="line">        <span class="keyword">self</span>.ballXVelocity = <span class="keyword">self</span>.ballXVelocity + (<span class="keyword">self</span>.acceleration.x * secondsSinceLastDraw);</span><br><span class="line">        <span class="comment">//X方向上原速度加上加速度乘以时间，计算当前速度</span></span><br><span class="line">        <span class="keyword">self</span>.ballYVelocity = <span class="keyword">self</span>.ballYVelocity - (<span class="keyword">self</span>.acceleration.y * secondsSinceLastDraw);</span><br><span class="line">        <span class="comment">//Y方向上原速度加上加速度乘以时间，计算当前速度</span></span><br><span class="line">        <span class="built_in">CGFloat</span> xAccel = secondsSinceLastDraw * <span class="keyword">self</span>.ballXVelocity * <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//计算位置变化量。由于这个值很小，所以我们要放大一些才更加真实此处</span></span><br><span class="line">        <span class="comment">//若想使用摇动，要把放大倍数调大，10000效果不错</span></span><br><span class="line">        <span class="built_in">CGFloat</span> yAccel = secondsSinceLastDraw * <span class="keyword">self</span>.ballYVelocity * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">self</span>.currentPoint = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.currentPoint.x + xAccel, <span class="keyword">self</span>.currentPoint.y + yAccel);</span><br><span class="line">    &#125;</span><br><span class="line">    lastUpdateTime = [<span class="built_in">NSDate</span> date];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - widthAndHeight</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)width&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.bounds.size.width;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">CGFloat</span>)height&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.bounds.size.height;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">CGFloat</span>)imageWidth&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.image.size.width;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">CGFloat</span>)imageHeight&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.image.size.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　这样你就可以实现，倾斜手机来移动图片，就像真是的重力产生的效果一样。同样也可以实现，摇动的效果。（就像安卓的360原来的版本有个摇动的球清理内存那样的效果）。<br>　　如需转载请注明出处，请尊重作者的劳动成果。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS开发10个使用小技巧]]></title>
      <url>http://nanshanyi.github.io/2016/06/27/xiaojiqiao/</url>
      <content type="html"><![CDATA[<p>在开发过程中我们总会遇到各种各样的小问题，有些小问题并不是十分容易解决。在此我就总结一下，我在开发中遇到的各种小问题，以及我的解决方法。比较普遍的我就不再提了，这里主要讲一些你可能不知道的（当然，也有可能你都知道，大神就不必往下看了）</p>
<h4 id="控件的局部圆角问题"><a href="#控件的局部圆角问题" class="headerlink" title="控件的局部圆角问题"></a>控件的局部圆角问题</h4><p>　　你是不是也遇到过这样的问题，一个button或者label，只要右边的两个角圆角，或者只要一个圆角。该怎么办呢。这就需要图层蒙版来帮助我们了<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"><span class="built_in">CGSize</span> radio = <span class="built_in">CGSizeMake</span>(<span class="number">5</span>, <span class="number">5</span>);<span class="comment">//圆角尺寸</span></span><br><span class="line"><span class="built_in">UIRectCorner</span> corner = <span class="built_in">UIRectCornerTopLeft</span>|<span class="built_in">UIRectCornerTopRight</span>;<span class="comment">//这只圆角位置</span></span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:rect byRoundingCorners:corner cornerRadii:radio];</span><br><span class="line"><span class="built_in">CAShapeLayer</span> *masklayer = [[<span class="built_in">CAShapeLayer</span> alloc]init];<span class="comment">//创建shapelayer</span></span><br><span class="line">masklayer.frame = button.bounds;</span><br><span class="line">masklayer.path = path.CGPath;<span class="comment">//设置路径</span></span><br><span class="line">button.layer.mask = masklayer;</span><br></pre></td></tr></table></figure></p>
<p>举例为button，其它继承自UIView的控件都可以<br><a id="more"></a></p>
<h4 id="navigationBar的透明问题"><a href="#navigationBar的透明问题" class="headerlink" title="navigationBar的透明问题"></a>navigationBar的透明问题</h4><p>　　如果仅仅把navigationBar的alpha设为0的话，那就相当于把navigationBar给隐藏了，大家都知道，父视图的alpha设置为0的话，那么子视图全都会透明的。那么相应的navigationBar的标题和左右两个按钮都会消失。这样显然达不到我们要求的效果。<br>　　（1）如果仅仅是想要navigationBar透明，按钮和标题都在可以使用以下方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.navigationController.navigationBar setBackgroundImage:[<span class="built_in">UIImage</span> new]</span><br><span class="line">forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];<span class="comment">//给navigationBar设置一个空的背景图片即可实现透明，而且标题按钮都在</span></span><br></pre></td></tr></table></figure></p>
<p>细心的你会发现上面有一条线如下图：<br><img src="http://upload-images.jianshu.io/upload_images/966908-3b7d38b83a9e353c.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IMG_0025.PNG"><br>这就需要我们做进一步处理，把线去掉，如下方法即可：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.navigationController.navigationBar.shadowImage = [<span class="built_in">UIImage</span> new];</span><br><span class="line"><span class="comment">//其实这个线也是image控制的。设为空即可</span></span><br></pre></td></tr></table></figure></p>
<p>　　（2）如果你想在透明的基础上实现根据下拉距离，由透明变得不透明的效果，那么上面那个就显得力不从心了，这就需要我们采用另外一种方法了<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//navigationBar是一个复合视图，它是有许多个控件组成的，那么我们就可以从他的内部入手</span></span><br><span class="line">[[<span class="keyword">self</span>.navigationController.navigationBar subviews] objectAtIndex:<span class="number">0</span>].alpha = <span class="number">0</span>;<span class="comment">//这里可以根据scrollView的偏移量来设置alpha就实现了渐变透明的效果</span></span><br></pre></td></tr></table></figure></p>
<h4 id="全局设置navigationBar标题的样式和barItem的标题样式"><a href="#全局设置navigationBar标题的样式和barItem的标题样式" class="headerlink" title="全局设置navigationBar标题的样式和barItem的标题样式"></a>全局设置navigationBar标题的样式和barItem的标题样式</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UIColorWithHexRGB( )这个方法是自己定义的，这里只需要给个颜色就好了</span></span><br><span class="line"> [[<span class="built_in">UINavigationBar</span> appearance] setBarTintColor:<span class="built_in">UIColorWithHexRGB</span>(<span class="number">0xfefefe</span>)];</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">UINavigationBar</span> appearance] setTitleTextAttributes:@&#123;<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">18</span>],<span class="built_in">NSForegroundColorAttributeName</span>:<span class="built_in">UIColorWithHexRGB</span>(<span class="number">0xfe6d27</span>)&#125;];</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">UITabBarItem</span> appearance] setTitleTextAttributes:@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">10</span>],<span class="built_in">NSForegroundColorAttributeName</span> : <span class="built_in">UIColorWithHexRGB</span>(<span class="number">0x666666</span>)&#125; forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">UITabBarItem</span> appearance] setTitleTextAttributes:@&#123;<span class="built_in">NSFontAttributeName</span> : [<span class="built_in">UIFont</span> boldSystemFontOfSiz</span><br></pre></td></tr></table></figure>
<h4 id="navigationBar隐藏显示的过度"><a href="#navigationBar隐藏显示的过度" class="headerlink" title="navigationBar隐藏显示的过度"></a>navigationBar隐藏显示的过度</h4><p>  　　相信在使用中肯定遇到过，一个页面隐藏navigationBar，另一个不隐藏。两个页面进行push和pop的时候，尤其是有侧滑手势返回的时候，不做处理就会造成滑动返回时，navigationBar位置是空的，直接显示一个黑色或者显示下面一层视图，很难看。这就需要我们加入过度动画来隐藏或显示navigationBar：<br>在返回后将要出现的页面实现viewWillAppear方法，需要隐藏就设为YES，需要显示就设为NO<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController setNavigationBarHidden:<span class="literal">NO</span> animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="侧滑手势返回"><a href="#侧滑手势返回" class="headerlink" title="侧滑手势返回"></a>侧滑手势返回</h4><p>  　　iOS的侧滑返回手势有着很好的操作体验，不支持侧滑返回的应用绝对不是好应用。但是在开发过程中在自定义了返回按钮，或者某些webView,tableView等页面，侧滑返回手势失效，这时候就需要我们来进行设置一下了,可以在基类里面协商如下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.navigationController respondsToSelector:<span class="keyword">@selector</span>(interactivePopGestureRecognizer)]) &#123;</span><br><span class="line"><span class="comment">//需要遵循一下手势的代理</span></span><br><span class="line">       <span class="keyword">self</span>.navigationController.interactivePopGestureRecognizer.delegate = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">self</span>.navigationController.interactivePopGestureRecognizer.enabled = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>  　　问题：当返回navigationController的最顶层的Controller的时候。再次侧滑，这个时候你在点击一个push页面的操作，你会发现卡那了，半天才会有反应。<br>  　　这是由于，在最顶层Controller手势依然有效，但是滑动后，并找不到返回的页面。造成软件卡顿，假死所以就要在rootViewController中让此手势失效。把下面的设为NO<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记得写在didAppear里面</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated&#123;</span><br><span class="line">    <span class="keyword">self</span>.navigationController.interactivePopGestureRecognizer.enabled = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  　　当然你也可以使用一个第三方库，写的相当棒。他对系统的侧滑返回手势进行拓展，不用从边缘滑动，只要右滑即可返回。最重要的是，他只需要加入项目中即可，不需要一行代码即可实现。附上&lt;a href=”<a href="https://github.com/forkingdog/FDFullscreenPopGesture&quot;target=&quot;blank&quot;" target="_blank" rel="noopener">https://github.com/forkingdog/FDFullscreenPopGesture&quot;target=&quot;blank&quot;</a> &gt;github 网址</p>
<h4 id="给webView添加头视图"><a href="#给webView添加头视图" class="headerlink" title="给webView添加头视图"></a>给webView添加头视图</h4><p>webView是一个复合视图，里面包含有一个scrollView，scrollView里面是一个UIWebBrowserView（负责显示WebView的内容）<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *webBrowserView = <span class="keyword">self</span>.webView.scrollView.subviews[<span class="number">0</span>];<span class="comment">//拿到webView的webBrowserView</span></span><br><span class="line">    <span class="keyword">self</span>.backHeadImageView = [[<span class="built_in">UIImageView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, kScreenWidth, kScreenWidth*<span class="number">2</span>/<span class="number">3.0</span>)];</span><br><span class="line">    [_backHeadImageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.imageUrl] placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholderImage"</span>]];</span><br><span class="line">    [<span class="keyword">self</span>.webView insertSubview:_backHeadImageView belowSubview:<span class="keyword">self</span>.webView.scrollView];</span><br><span class="line">    <span class="comment">//把backHeadImageView插入到webView的scrollView下面</span></span><br><span class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.webBrowserView.frame;</span><br><span class="line">    frame.origin.y = <span class="built_in">CGRectGetMaxY</span>(_backHeadImageView.frame);</span><br><span class="line">    <span class="keyword">self</span>.webBrowserView.frame = frame;</span><br><span class="line">    <span class="comment">//更改webBrowserView的frame向下移backHeadImageView的高度，使其可见</span></span><br></pre></td></tr></table></figure></p>
<h4 id="模态跳转的动画设置"><a href="#模态跳转的动画设置" class="headerlink" title="模态跳转的动画设置"></a>模态跳转的动画设置</h4><p>  　　设置模态跳转的动画，系统提供了四种可供选择<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DetailViewController *detailVC = [[DetailViewController alloc]init];</span><br><span class="line"><span class="comment">//UIModalTransitionStyleFlipHorizontal 翻转</span></span><br><span class="line"><span class="comment">//UIModalTransitionStyleCoverVertical 底部滑出</span></span><br><span class="line"><span class="comment">//UIModalTransitionStyleCrossDissolve 渐显</span></span><br><span class="line"><span class="comment">//UIModalTransitionStylePartialCurl 翻页</span></span><br><span class="line">detailVC.modalTransitionStyle = <span class="built_in">UIModalTransitionStylePartialCurl</span>;</span><br><span class="line">[<span class="keyword">self</span> presentViewController:detailVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p>
<h4 id="图片处理只拿到图片的一部分"><a href="#图片处理只拿到图片的一部分" class="headerlink" title="图片处理只拿到图片的一部分"></a>图片处理只拿到图片的一部分</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:filename];</span><br><span class="line"><span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(origin.x, origin.y ,size.width, size.height);</span><br><span class="line"><span class="comment">//这里的宽高是相对于图片的真实大小</span></span><br><span class="line"><span class="comment">//比如你的图片是400x400的那么（0，0，400，400）就是图片的全尺寸，想取哪一部分就设置相应坐标即可</span></span><br><span class="line"><span class="built_in">CGImageRef</span> imageRefRect = <span class="built_in">CGImageCreateWithImageInRect</span>(imageRef, rect);</span><br><span class="line"><span class="built_in">UIImage</span> *imageRect = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:imageRefRect];</span><br></pre></td></tr></table></figure>
<h4 id="给UIView设置图片"><a href="#给UIView设置图片" class="headerlink" title="给UIView设置图片"></a>给UIView设置图片</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"playing"</span>];</span><br><span class="line">    _layerView.layer.contents = (__bridge <span class="keyword">id</span>)image.CGImage;</span><br><span class="line">_layerView.layer.contentsCenter = <span class="built_in">CGRectMake</span>(<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"><span class="comment">//同样可以设置显示的图片范围</span></span><br><span class="line"><span class="comment">//不过此处略有不同，这里的四个值均为0-1之间；对应的依然是写x,y,widt,height</span></span><br></pre></td></tr></table></figure>
<h4 id="给TableView或者CollectionView的cell添加简单动画，像这样"><a href="#给TableView或者CollectionView的cell添加简单动画，像这样" class="headerlink" title="给TableView或者CollectionView的cell添加简单动画，像这样"></a>给TableView或者CollectionView的cell添加简单动画，像这样</h4><p><img src="http://upload-images.jianshu.io/upload_images/966908-4f826be8fca0bb4a.gif?imageMogr2/auto-orient/strip" alt="888.gif"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/966908-a6cf7dd499ba351e.gif?imageMogr2/auto-orient/strip" alt="555.gif"><br>只要在willDisplayCell方法中对将要显示的cell做动画即可：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *array =  tableView.indexPathsForVisibleRows;</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *firstIndexPath = array[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置anchorPoint</span></span><br><span class="line">    cell.layer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//为了防止cell视图移动，重新把cell放回原来的位置</span></span><br><span class="line">    cell.layer.position = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, cell.layer.position.y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置cell 按照z轴旋转90度，注意是弧度</span></span><br><span class="line">    <span class="keyword">if</span> (firstIndexPath.row &lt; indexPath.row) &#123;</span><br><span class="line">            cell.layer.transform = <span class="built_in">CATransform3DMakeRotation</span>(M_PI_2, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cell.layer.transform = <span class="built_in">CATransform3DMakeRotation</span>(- M_PI_2, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cell.alpha = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">1</span> animations:^&#123;</span><br><span class="line">        cell.layer.transform = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">        cell.alpha = <span class="number">1.0</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView willDisplayCell:(<span class="built_in">UICollectionViewCell</span> *)cell forItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        cell.transform = <span class="built_in">CGAffineTransformTranslate</span>(cell.transform, kScreenWidth/<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cell.transform = <span class="built_in">CGAffineTransformTranslate</span>(cell.transform, -kScreenWidth/<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cell.alpha = <span class="number">0.0</span>;</span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.7</span> animations:^&#123;</span><br><span class="line">        cell.transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">        cell.alpha = <span class="number">1.0</span>;</span><br><span class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如需转载请注明出处，请尊重作者的劳动成果。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS技巧 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS10上手]]></title>
      <url>http://nanshanyi.github.io/2016/06/14/iOS10%E4%B8%8A%E6%89%8B/</url>
      <content type="html"><![CDATA[<p>Apple 在今天凌晨发布了全新一代的操作系统iOS10.0beta，今天在第一时间用iPhone6sP更新了该系统，现在通过系统截图给大家带来第一手的体验。<br><img src="/2016/06/14/iOS10上手/966908-8b373729ba35b9a3.png" width="60%" height="60%"><br>　　iOS10的锁屏界面改变较大，原有的“向右滑动解锁”功能被“按下主频幕按钮以打开”替换，也就是说第一下按点亮屏幕，再按一下方可解锁。如果使用Touch ID还是直接解锁。但是新加入的拿起亮屏，放下熄屏。真的很赞，要看一下时间，直接拿起屏幕就点亮。锁屏界面左滑出现widget，等控件。<br><a id="more"></a><br><img src="/2016/06/14/iOS10上手/966908-c1ecb4451c126850.png" width="60%" height="60%"></p>
<p><img src="/2016/06/14/iOS10上手/966908-c3ce28564877bc2b.png" width="60%" height="60%"><br>　　右滑则是打开相机操作。相机本身也是左右滑动切换功能，所以不能在滑动返回，只能点击home键。点击编辑可以添加Widget。锁屏界面的通知也是卡片式的。按压可以预览消息详情,可以直接进行消息回复</p>
<p><img src="/2016/06/14/iOS10上手/966908-bd456476ef5722d3.png" width="60%" height="60%"></p>
<p><img src="/2016/06/14/iOS10上手/966908-3210e9cdbfdadbfb.png" width="60%" height="60%"></p>
<p>　　主屏幕变化不是很大跟原来基本保持一致。长安可以删除图标，系统应用也支持卸载了（这里并没有真正的卸载，只是隐藏掉了应用图标而已，另外文件夹打开的毛玻璃效果也比原来更加透明了。新添加了家庭系统应用，不过我们用基本没用<br><img src="/2016/06/14/iOS10上手/966908-0cbf31b5589d5970.png" width="60%" height="60%"><br> 　　下拉通知栏现在只有一栏（在桌面的时候只有一栏）,在应用里面时下拉会有两栏，左边一栏还是widget。<br><img src="/2016/06/14/iOS10上手/966908-eb12e8404ff4ad5b.png" width="60%" height="60%"></p>
<p><img src="/2016/06/14/iOS10上手/966908-b76a0d19081f1bbd.png" width="60%" height="60%"><br>　　控制中心变化还是比较明显的，样式变为了卡片式，上面的快捷开关没有加入3D Touch略有遗憾。下面的手电筒等快捷方式加入了3D Touch操作.左滑是音乐控制卡片</p>
<p><img src="/2016/06/14/iOS10上手/966908-47ad13018918c9a0.png" width="60%" height="60%"><br><img src="/2016/06/14/iOS10上手/966908-94f87f47fc40def5.png" width="60%" height="60%"><br><img src="/2016/06/14/iOS10上手/966908-aef33cc77453af61.png" width="60%" height="60%"></p>
<p>　　现在不管应用是否支持3D Touch，按压都会有一个share选项。原有支持的应用也都会增加一个share项。设置的3D Touch菜单添加了蜂窝移动数据选项。另外在无线网的设置中新添加了联网管理，可以设置单个应用在wifi下或在数据流量下，或者二者均可联网。但是汉化略有问题<br><img src="/2016/06/14/iOS10上手/966908-a53e9ef235150671.png" width="60%" height="60%"></p>
<p><img src="/2016/06/14/iOS10上手/966908-85ec905f8b654cae.png" width="60%" height="60%"><br>  　　设置中新添加了Siri项和图标，其他的东西没什么变化<br><img src="/2016/06/14/iOS10上手/966908-844b6900f27540e7.png" width="60%" height="60%"><br>  　　本次更新message变化还是比较大的，添加了好多功能，新的表情，和新的手写输入，直接发送<br><img src="/2016/06/14/iOS10上手/966908-9f51fd4d3ef825d0.png" width="60%" height="60%"><br><img src="/2016/06/14/iOS10上手/966908-3a16530c12cfcbc3.png" width="60%" height="60%"></p>
<p><img src="/2016/06/14/iOS10上手/966908-ecb2b3146f647b36.png" width="60%" height="60%"><br>  　　健康应用的UI变化也比较大，这里发现一个BUG，步数距离和楼层是可以3D Touch预览的，左右滑动可以切换日期。但是切换到昨天后按压预览，数据现实的还是今天的<br><img src="/2016/06/14/iOS10上手/966908-f014db15256c6be1.png" width="60%" height="60%"></p>
<p><img src="/2016/06/14/iOS10上手/966908-9bd74d9190e5c978.png" width="60%" height="60%"><br><img src="/2016/06/14/iOS10上手/966908-aa3aa7c3082ac73c .png" width="60%" height="60%"><br>  　　时钟采用了黑色主题，全黑的。感觉没有白色的好看，可以看一下</p>
<p><img src="/2016/06/14/iOS10上手/966908-d7af8c36d981ecdd.png" width="60%" height="60%"></p>
<p>  　　地图和相册也进行了相应功能的添加，由于变化算大，这里就不再提了苹果也在iOS10中表现出了足够多的开放诚意，目前Siri、iMessage、苹果地图服务均向第三方应用开放，以供开发者使用。苹果的照片功能进步比较明显，当然你也可以说它与谷歌相册更加接近了，除了支持自动识别面部以及场景外，它还能像谷歌相册一样自动创建索引，并进行关键字的高级搜索，新增的回忆功能相当不错，苹果提供了默认的几种设置组合，可从云端下载配乐，然后它会按照歌曲的旋律节奏自动进行合理的剪辑，出来的效果还是相当出色的。<br>  　　如果你也想体验iOS10，<a href="http://pan.baidu.com/s/1ge7uFnX" target="_blank" rel="noopener">点击</a>用safari打开，安装此描述文件，即可检查更新到iOS10，更新升级即可。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS10 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo创建个人博客]]></title>
      <url>http://nanshanyi.github.io/2016/06/05/hexoBlog/</url>
      <content type="html"><![CDATA[<p>你是不是见多了各种大v的个人博客，是不是也想拥有这样的一个个人博客，（静静的装B！）看这里，就对了。一步一步教你创建自己的博客。<br>　　现在用的比较多的就是<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>（快速、简洁且高效的博客框架），支持markDown，有丰富的插件和主题</p>
<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>　　安装<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a> 和 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>,git就不用多说了，如果连git都不会装，请出去把门关上。<br>　　Node.js 的安装可以使用两种方法，1、点击前面链接直接下载安装即可 2、通过终端命令行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure></p>
<p>之后重启终端，如果还找不到nvm命令可尝试重启电脑<br>接着执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install 4</span><br></pre></td></tr></table></figure></p>
<p>即可安装完成<br>以上两个条件已具备的话，即可开始安装hexo博客框架<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<p>执行完成后hexo就安装成功了，第一步结束，环境配置完毕可以开始创建自己的博客了<br><a id="more"></a></p>
<h3 id="github上创建仓库"><a href="#github上创建仓库" class="headerlink" title="github上创建仓库"></a>github上创建仓库</h3><p>　　github帐号的创建我也不再次赘述了。下面说一下仓库的创建，名字前面部分可以自己随便起。后面部分统一为github.io ，其他的均不需设置。如下图：<br><img src="/2016/06/05/hexoBlog/image1.png" width="%60" height="%60"></p>
<h3 id="博客的创建"><a href="#博客的创建" class="headerlink" title="博客的创建"></a>博客的创建</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Desktop  //cd到你的桌面执行：（init 后面的就是你的名字，当然你也可以随便起，不影响的，仅仅是创建一个文件夹）</span><br><span class="line">$ hexo init nanshanyi.github.io</span><br></pre></td></tr></table></figure>
<p>桌面会生成一个文件夹nanshanyi.github.io</p>
<h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><p>　　打开_config.yml文件进行基础配置（可以使用<a href="http://www.sublimetext.com/" target="_blank" rel="noopener">sublime</a>或者<a href="https://atom.io/" target="_blank" rel="noopener">atom</a>来打开，都是很很强大的代码编辑器，可安装各种插件，前端开发必备）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">title: 南山亿的技术博客   //博客名字</span><br><span class="line">subtitle: 积少成多    //小标题可以写自己喜欢的话</span><br><span class="line">description:          //博客描述</span><br><span class="line">author: 南山忆     //作者名字</span><br><span class="line">language: zh-Hans   //语言（此处为简体中文）</span><br><span class="line">url:  //自己购买的域名网址（没有可不写）</span><br><span class="line">theme：   //主题的名字</span><br><span class="line">deploy:</span><br><span class="line">type: git //使用git发布</span><br><span class="line">repo: https://github.com/nanshanyi/nanshanyi.github.io.git //刚刚创建的github仓库的地址</span><br></pre></td></tr></table></figure></p>
<h4 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h4><p>　　博客要想炫酷漂亮，一款合适的主题必不可少，hexo本身就提供了50种<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a> 可以预览查看，选择一款自己喜欢的主题<br>　　点击图片即可预览，看到此主题的效果，点击蓝色主题名即可进入此主题的github仓库，一般主题作者都写有使用方法。<br><img src="/2016/06/05/hexoBlog/image2.png" width="%60" height="%60"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 到nanshanyi.github.io文件下</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>　　这里使用的是一款简约漂亮的主题，使用的人挺多的。之后就可以在nanshanyi.github.io/themes目录下看到nex（以下next均为主题名，路径中为主题文件夹名。使用的主题不同只要把next换成相应的名字即可）主题。这个主题有三种布局展示形式，可自行挑选主题的详细配置<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">请看这里</a></p>
<h4 id="创建博客文章与发布"><a href="#创建博客文章与发布" class="headerlink" title="创建博客文章与发布"></a>创建博客文章与发布</h4><p>　　在nanshanyi.github.io 目录下终端命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &apos;文件名&apos; //会在source/_posts创建一个文件名.md文件</span><br></pre></td></tr></table></figure></p>
<p>　　这就可以使用markdown编辑器开始写自己的博客了（上面提到有工具）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: new//博客标题</span><br><span class="line">date: 2016-05-10 10:47:49 //创建时间</span><br><span class="line">tags:  //分类标签</span><br><span class="line">---</span><br><span class="line">　　这里写正文（上面的---是必要的）</span><br></pre></td></tr></table></figure></p>
<p>　　本地查看效果预览<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p>
<p>　　浏览器打开<a href="https://localhost:4000" target="_blank" rel="noopener">https://localhost:4000</a> 即可查看效果<br>　　发布到 github：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d //发布到 github</span><br></pre></td></tr></table></figure></p>
<p>　　发布到 github 后可以使用 <a href="http://nanshanyi.github.io">http://nanshanyi.github.io</a> 访问（请使用你自己的网址）</p>
<h4 id="博客中插入图片-音乐"><a href="#博客中插入图片-音乐" class="headerlink" title="博客中插入图片,音乐"></a>博客中插入图片,音乐</h4><p>　　基本分为两种办法<br>（1）放在本地文件<br>首先在nanshanyi.github.io目录下确认_config.yml 中有 post_asset_folder:true 。<br> 在 hexo 目录，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>　　之后再使用 hexo new ‘new’创建新博客的时候，会在source/_posts里面创建.md文件的同时生成一个相同的名字的文件夹。<br>把该文章中需要使用的图片放在该文件夹下即可。<br>使用的时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![“图片描述”（可以不写）](/文件夹名/你的图片名字.JPG)</span><br><span class="line">例如：</span><br><span class="line">！[ ] (new/text.jpg)</span><br></pre></td></tr></table></figure></p>
<p>  （2）放在<a href="https://portal.qiniu.com/signup?code=3lglas6pgi2qa" target="_blank" rel="noopener">七牛</a>上，需要先注册，上传图片生成链接，直接在文章中使用链接即可。<br>  （3）插入音乐<br>　　可以使用网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器；复制代码，直接粘贴到博文中即可。这样会显示一个网易的播放器，可以把<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;http://music.163.com/outchain/player?type=2&amp;id=32192436&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">//其中的width=298 height=52 均改为0就看不到了，依然可以播放音乐</span><br></pre></td></tr></table></figure></p>
<p><img src="/2016/06/05/hexoBlog/image3.png" width="%60" height="%60"><br><img src="/2016/06/05/hexoBlog/image4.png" width="%60" height="%60"></p>
<h3 id="集成多说评论，分享"><a href="#集成多说评论，分享" class="headerlink" title="集成多说评论，分享"></a>集成多说评论，分享</h3><p>　　申请<a href="http://duoshuo.com/" target="_blank" rel="noopener">多说</a>帐号,打开页面点击我要安装注册帐号<br><img src="/2016/06/05/hexoBlog/image5.png" width="%60" height="%60"></p>
<p>　　在themes/next目录下打开 _config.yml，设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">duoshuo_shortname:  nanshanyi //上面多说域名中填的内容</span><br><span class="line">需要分享的打开duoshuo_share: true 即可，支持分享到微博、QQ空间、微信</span><br></pre></td></tr></table></figure></p>
<p>然后打开themes\landscape\layout_partial\article.ejs文件<br>把以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</span><br><span class="line">&lt;section id=&quot;comments&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;disqus_thread&quot;&gt;</span><br><span class="line">    &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p>
<p>替换为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt;</span><br><span class="line">  &lt;section id=&quot;comments&quot;&gt;</span><br><span class="line">    &lt;!-- 多说评论框 start --&gt;</span><br><span class="line">    &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- 多说评论框 end --&gt;</span><br><span class="line">    &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var duoshuoQuery = &#123;short_name:&apos;&lt;%= config.duoshuo_shortname %&gt;&apos;&#125;;</span><br><span class="line">      (function() &#123;</span><br><span class="line">        var ds = document.createElement(&apos;script&apos;);</span><br><span class="line">        ds.type = &apos;text/javascript&apos;;ds.async = true;</span><br><span class="line">        ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;;</span><br><span class="line">        ds.charset = &apos;UTF-8&apos;;</span><br><span class="line">        (document.getElementsByTagName(&apos;head&apos;)[0]</span><br><span class="line">         || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds);</span><br><span class="line">      &#125;)();</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">    &lt;!-- 多说公共JS代码 end --&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后你hexo s ,打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 打开文章看一下，评论和分享已经静静的躺在那了<br><img src="/2016/06/05/hexoBlog/image6.png" width="%60" height="%60"></p>
<h3 id="添加标签页"><a href="#添加标签页" class="headerlink" title="添加标签页"></a>添加标签页</h3><p>　　在nanshanyi.github.io文件目录下执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page tags //会在nanshanyi.github.io/source下创建tags文件夹内部是一个index.md和index文件夹</span><br></pre></td></tr></table></figure></p>
<p>修改nanshanyi.github.io/themes/next/_config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /      //主页</span><br><span class="line">  #categories: /categories //分类</span><br><span class="line">  archives: /archives   //归档</span><br><span class="line">  tags: /tags   //标签（添加此行即可）</span><br><span class="line">  about: /about   //关于</span><br><span class="line">  #commonweal: /404.html</span><br></pre></td></tr></table></figure></p>
<p>首页菜单就会有便签项，点击即可进入标签页。</p>
<h3 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h3><p>　　next支持Swiftype 、微搜索和Local Search<br>　　（1）Swiftype （收费的没有免费版，进可以使用15天）是为网站和移动应用提供内部搜索的工具，点击进入<a href="https://swiftype.com/users/sign_up" target="_blank" rel="noopener">Swiftype注册页面</a> ，注册之后需要填写自己的博客的网址<br>然后选择<br><img src="/2016/06/05/hexoBlog/image7.png" width="%60" height="%60"><br>选择 install Search<br><img src="/2016/06/05/hexoBlog/image8.png" width="%60" height="%60"><br>途中的即为swiftype_key<br>修改nanshanyi.github.io/themes/next/_config.yml中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftype_key:上面红圈中的内容</span><br></pre></td></tr></table></figure></p>
<p>点击 resume Configuration 选择 search field edit<br><img src="/2016/06/05/hexoBlog/image9.png" width="%60" height="%60"><br>save<br>发布即可看到效果<br><img src="/2016/06/05/hexoBlog/image10.png" width="%60" height="%60"><br>    （2）添加本地搜索<br>安装 hexo-generator-search，在nanshanyi.github.io目录下执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></p>
<p>在nanshanyi.github.io/themes/next/_config.yml添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">      path: search.xml</span><br><span class="line">      field: post</span><br></pre></td></tr></table></figure></p>
<p>  发布即可看到效果，和上面的 swiftType 效果差不多，就不再粘图片了。</p>
]]></content>
      
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS JavaScriptCore实现OC与JS的交互]]></title>
      <url>http://nanshanyi.github.io/2016/05/22/jstooc/</url>
      <content type="html"><![CDATA[<p>  JS 与 OC 的交互原来没有好好研究过，用的都是比较简单拦截 Url 的方式，通过定义专用的 Url 来拦截关键字来进行特定处理。但这只能用于简单的传值，进行一些简单的交互。涉及到，JS 调用 OC 方法或者 OC 调用 JS 方法，一些比较复杂的交互逻辑的时候这种方式就显得力不从心了。满足不了我们的需求。当然也有比较好的第三方库如：WebViewJavascriptBridge。但一般系统的方法足够用的时候，就没必要使用第三方库。这样即有利于减小安装包体积，又可以减少第三方的不稳定性等因素的干扰</p>
<h3 id="拦截url的方式，进行简单交互"><a href="#拦截url的方式，进行简单交互" class="headerlink" title="拦截url的方式，进行简单交互"></a>拦截url的方式，进行简单交互</h3><p>　　在webView的代理方法中处理<br>　　这里简单介绍一下 URL 里面的一些属性<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *scheme = url.scheme;<span class="comment">//协议：http</span></span><br><span class="line"><span class="built_in">NSString</span> *host = url.host;<span class="comment">//主机名</span></span><br><span class="line"><span class="built_in">NSNumber</span> *port = url.port;<span class="comment">//端口号</span></span><br><span class="line"><span class="built_in">NSString</span> *path = url.path;<span class="comment">//一般用来表示主机上的一个目录或文件地址</span></span><br><span class="line"><span class="built_in">NSString</span> *query = url.query;<span class="comment">//参数，发给服务器的参数</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = request.URL;</span><br><span class="line">    <span class="keyword">if</span> ([url.scheme isEqualToString:<span class="string">@"nanshanyi"</span>]) &#123;</span><br><span class="line">        <span class="comment">//在这里做JavaScript调用Objective-C的事。</span></span><br><span class="line">        <span class="comment">//需要传的值放在url后面的参数里如：Nanshanyi://www.php8080.com?&#123;"title":"标题","id":"123","des":"描述内容"&#125;</span></span><br><span class="line">        <span class="built_in">NSString</span> *dataJson = url.query;<span class="comment">//拿到后面的json字符串</span></span><br><span class="line">       <span class="built_in">NSString</span> *str = [dataJson stringByReplacingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str);</span><br><span class="line"><span class="comment">//执行一段js代码，弹出提示框</span></span><br><span class="line">        [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"alert('seccess')"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用JavaScriptCore实现交互"><a href="#使用JavaScriptCore实现交互" class="headerlink" title="使用JavaScriptCore实现交互"></a>使用JavaScriptCore实现交互</h3><p>　　JavaScriptCore是封装了JavaScript和Objective-C桥接的Objective-C API，只需要较少的的代码，就可以实现JavaScript与Objective-C的相互调用。<br>　　在iOS7之前，只能通过向UIWebView发送stringByEvaluatingJavaScriptFromString:消息来执行一段JavaScript的脚本。而且如果想用JavaScript来调用Objective-C的方法，必须打开一个自定义的URL（例如：Nanshanyi://），然后在UIWebView的delegate方法webView:shouldStartLoadWithRequest:navigationType中进行处理。也就是上问中提到的方法<br>JavaScriptCore中类及协议：<br>　　JSContext：给JavaScript提供运行的上下文环境<br>　　JSValue：JavaScript和Objective-C数据和方法的桥梁<br>　　 JSManagedValue：管理数据和方法的类<br>　　JSVirtualMachine：处理线程相关，使用较少<br>　　JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议</p>
<h4 id="使用Delegate方式实现"><a href="#使用Delegate方式实现" class="headerlink" title="使用Delegate方式实现"></a>使用Delegate方式实现</h4><p>先放上js的网页代码，可以建一个HTML文件直接复制进去即可使用<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>OC和JS的交互代理方式<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 生成一个 button 添加点击事件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"JsToOcShare"</span> <span class="attr">onclick</span>=<span class="string">"callShare()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    function callShare() &#123;</span><br><span class="line">        var shareContent = JSON.stringify(&#123;"title": "分享", "desc": "分享内容", "shareUrl": "http://www.jianshu.com/users/774b1d5616a7/latest_articles"&#125;);</span><br><span class="line">        Nanshanyi.share(shareContent);</span><br><span class="line">    &#125;</span><br><span class="line">    //   OC调JS</span><br><span class="line">    function showAlert(message)&#123;</span><br><span class="line">        alert(message);</span><br><span class="line">    &#125;</span><br><span class="line">    //    JS调OC成功后回调</span><br><span class="line">    var shareCallback = function()&#123;</span><br><span class="line">        alert('success');</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">JSObjcDelegate</span> &lt;<span class="title">JSExport</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)share:(<span class="built_in">NSString</span> *)shareContent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span>&lt;<span class="title">JSObjcDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>.m文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()&lt;<span class="title">UIWebViewDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">UIWebView</span> *webView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)JSContext *jsContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> CustomUI];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)CustomUI&#123;</span><br><span class="line">    <span class="keyword">self</span>.webView = [[<span class="built_in">UIWebView</span> alloc]initWithFrame:<span class="keyword">self</span>.view.bounds];</span><br><span class="line">    <span class="keyword">self</span>.webView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:_webView];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"untitled3"</span> withExtension:<span class="string">@"html"</span>];</span><br><span class="line">    [<span class="keyword">self</span>.webView loadRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:url]];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView&#123;</span><br><span class="line">    _jsContext = [webView valueForKeyPath:<span class="string">@"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">    <span class="comment">//代理方式JS调OC方法</span></span><br><span class="line">    <span class="comment">//Nanshanyi 相当于桥接，通过它将 OC 与 JS 联系起来</span></span><br><span class="line">    _jsContext[<span class="string">@"Nanshanyi"</span>] = <span class="keyword">self</span>;</span><br><span class="line">    _jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123;</span><br><span class="line">        context.exception = exceptionValue;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"异常信息：%@"</span>, exceptionValue);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)share:(<span class="built_in">NSString</span> *)shareContent &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"share:%@"</span>, shareContent);</span><br><span class="line">    <span class="comment">// 分享成功后,回调js的方法shareCallback</span></span><br><span class="line"><span class="comment">//    也即是 OC 调用 JS 方法,只调用方法，没有参数传递</span></span><br><span class="line">    JSValue *shareCallback = <span class="keyword">self</span>.jsContext[<span class="string">@"shareCallback"</span>];</span><br><span class="line">    [shareCallback callWithArguments:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用Block方式实现"><a href="#使用Block方式实现" class="headerlink" title="使用Block方式实现"></a>使用Block方式实现</h4><p>同样放上一段简单的JS<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>OC和JS的交互Block方式<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"JsToOcShare"</span> <span class="attr">onclick</span>=<span class="string">"callShare(shareContent)"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    var shareContent = JSON.stringify(&#123;"title":"分享", "desc":"分享内容", "shareUrl":"http://www.jianshu.com/users/774b1d5616a7/latest_articles"&#125;);</span><br><span class="line"></span><br><span class="line">    function callShare(share) &#123;</span><br><span class="line">    //share为形参，shareContent为实参，即要传递的参数</span><br><span class="line">    &#125;</span><br><span class="line">    //  OC调JS message为传递的参数</span><br><span class="line">    function showAlert(message)&#123;</span><br><span class="line">        alert(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>WebView代理方法的实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)showAlert&#123;<span class="comment">//直接调用该方法实现OC调用JS，并传参</span></span><br><span class="line">    <span class="built_in">NSString</span> *jsStr = <span class="string">@"showAlert('ios js交互成功,我是网页 alert')"</span>;</span><br><span class="line">    [_jsContext evaluateScript:jsStr];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView&#123;</span><br><span class="line">    _jsContext = [webView valueForKeyPath:<span class="string">@"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">    <span class="comment">//block 方式 JS直接调用OC，并传参，简单明了</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>  (<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        _jsContext[<span class="string">@"callShare"</span>] =^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">            weakSelf.lable.text = obj;</span><br><span class="line">    <span class="comment">//把传过来的Json字符串，转为字典</span></span><br><span class="line">            <span class="built_in">NSData</span> *data = [(<span class="built_in">NSString</span> *)obj dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span> ];</span><br><span class="line">            <span class="built_in">NSDictionary</span> *dict = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableContainers</span> error:<span class="literal">nil</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,dict);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    _jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123;</span><br><span class="line">        context.exception = exceptionValue;</span><br><span class="line">  <span class="comment">//比如把js中的方法名改掉，OC找不到相应方法，这里就会打印异常信息</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"异常信息：%@"</span>, exceptionValue);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　至此，已经完成了JS与OC的简单交互，实现了JS与OC方法的相互调用，与传值。有什么不对的请批评指正，互相学习</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS原生方法实现二维码生成与扫描]]></title>
      <url>http://nanshanyi.github.io/2016/05/10/qrcode/</url>
      <content type="html"><![CDATA[<p>二维码的生成有好多第三方库，如Z-Xing。但是为了控制安装包的大小，或者并不需要其他的一些额外的功能，用系统的方法即可满足.</p>
<h3 id="二维码的生成"><a href="#二维码的生成" class="headerlink" title="二维码的生成"></a>二维码的生成</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)createNonInterpolatedUIImageFormCIImage:(<span class="built_in">CIImage</span> *)image withSize:(<span class="built_in">CGFloat</span>) size waterImageSize:(<span class="built_in">CGFloat</span>)waterImagesize&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> extent = <span class="built_in">CGRectIntegral</span>(image.extent);</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = MIN(size/<span class="built_in">CGRectGetWidth</span>(extent), size/<span class="built_in">CGRectGetHeight</span>(extent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建bitmap;</span></span><br><span class="line">    size_t width = <span class="built_in">CGRectGetWidth</span>(extent) * scale;</span><br><span class="line">    size_t height = <span class="built_in">CGRectGetHeight</span>(extent) * scale;</span><br><span class="line">    <span class="comment">//创建一个DeviceGray颜色空间</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> cs = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line">    <span class="comment">//CGBitmapContextCreate(void * _Nullable data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef  _Nullable space, uint32_t bitmapInfo)</span></span><br><span class="line">    <span class="comment">//width：图片宽度像素</span></span><br><span class="line">    <span class="comment">//height：图片高度像素</span></span><br><span class="line">    <span class="comment">//bitsPerComponent：每个颜色的比特值，例如在rgba-32模式下为8</span></span><br><span class="line">    <span class="comment">//bitmapInfo：指定的位图应该包含一个alpha通道。</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> bitmapRef = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, cs, (<span class="built_in">CGBitmapInfo</span>)kCGImageAlphaNone);</span><br><span class="line">    <span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//创建CoreGraphics image</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> bitmapImage = [context createCGImage:image fromRect:extent];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextSetInterpolationQuality</span>(bitmapRef, kCGInterpolationNone);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(bitmapRef, scale, scale);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(bitmapRef, extent, bitmapImage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.保存bitmap到图片</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> scaledImage = <span class="built_in">CGBitmapContextCreateImage</span>(bitmapRef);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(bitmapRef); <span class="built_in">CGImageRelease</span>(bitmapImage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原图</span></span><br><span class="line">    <span class="built_in">UIImage</span> *outputImage = [<span class="built_in">UIImage</span> imageWithCGImage:scaledImage];</span><br><span class="line">    <span class="comment">//给二维码加 logo 图</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(outputImage.size, <span class="literal">NO</span>, [[<span class="built_in">UIScreen</span> mainScreen] scale]);</span><br><span class="line">    [outputImage drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span> , size, size)];</span><br><span class="line">    <span class="comment">//logo图</span></span><br><span class="line">    <span class="built_in">UIImage</span> *waterimage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"icon_imgApp"</span>];</span><br><span class="line">    <span class="comment">//把logo图画到生成的二维码图片上，注意尺寸不要太大（最大不超过二维码图片的%30），太大会造成扫不出来</span></span><br><span class="line">    [waterimage drawInRect:<span class="built_in">CGRectMake</span>((size-waterImagesize)/<span class="number">2.0</span>, (size-waterImagesize)/<span class="number">2.0</span>, waterImagesize, waterImagesize)];</span><br><span class="line">    <span class="built_in">UIImage</span> *newPic = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> newPic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="这个是官方文档中对inputMessage和inputCorrectionLevel的解释"><a href="#这个是官方文档中对inputMessage和inputCorrectionLevel的解释" class="headerlink" title="这个是官方文档中对inputMessage和inputCorrectionLevel的解释"></a>这个是官方文档中对inputMessage和inputCorrectionLevel的解释</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  [<span class="built_in">CIQRCodeGenerator</span> ](https:<span class="comment">//developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/#//apple_ref/doc/filter/ci/CIQRCodeGenerator)</span></span><br><span class="line"></span><br><span class="line">Generates a Quick Response code (two-dimensional barcode) from input data.</span><br><span class="line">Parameters</span><br><span class="line">*inputMessage*</span><br><span class="line">The data to be encoded as a QR code. AnNSData</span><br><span class="line">object whose display name is Message.</span><br><span class="line"></span><br><span class="line">*inputCorrectionLevel*</span><br><span class="line">A single letter specifying the error correction format. AnNSString</span><br><span class="line">object whose display name is CorrectionLevel.</span><br><span class="line">Default value:M</span><br><span class="line"></span><br><span class="line">Discussion</span><br><span class="line">    Generates an output image representing the input data according to the ISO/IEC <span class="number">18004</span>:<span class="number">2006</span> standard. The width and height of each module (square dot) of the code <span class="keyword">in</span> the output image is one point. To create a QR code from a string or URL, convert it to an[<span class="built_in">NSData</span>](https:<span class="comment">//developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSData_Class/index.html#//apple_ref/occ/cl/NSData)object using the[NSISOLatin1StringEncoding](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/c/econst/NSISOLatin1StringEncoding)string encoding.</span></span><br><span class="line">The*inputCorrectionLevel*</span><br><span class="line">　　parameter controls the amount of additional data encoded <span class="keyword">in</span> the output image to provide error correction. Higher levels of error correction result <span class="keyword">in</span> larger output images but allow larger areas of the code to be damaged or obscured without. There are four possible correction modes (with corresponding error resilience levels):</span><br><span class="line">L　: <span class="number">7</span>%</span><br><span class="line">M　: <span class="number">15</span>%</span><br><span class="line">Q　: <span class="number">25</span>%</span><br><span class="line">H　: <span class="number">30</span>%</span><br><span class="line"></span><br><span class="line">Member Of</span><br><span class="line"><span class="built_in">CICategoryBuiltIn</span></span><br><span class="line">,<span class="built_in">CICategoryStillImage</span></span><br><span class="line">,<span class="built_in">CICategoryGenerator</span></span><br><span class="line">Sample Output</span><br><span class="line"> **Figure <span class="number">91</span>**The result of using the <span class="built_in">CIQRCodeGenerator</span> filter ![image: ../Art/<span class="built_in">CIQRCodeGenerator</span>.pdf](https:<span class="comment">//developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/Art/CIQRCodeGenerator_2x.png)</span></span><br></pre></td></tr></table></figure>
<p>　　修改二维码的颜色,这一段是在网上找的，把生成的二维码图片传入，再传入想要的颜色即可<br>　　图片要传没有加过 logo 的<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span>*)imageBlackToTransparent:(<span class="built_in">UIImage</span>*)image withRed:(<span class="built_in">CGFloat</span>)red andGreen:(<span class="built_in">CGFloat</span>)green andBlue:(<span class="built_in">CGFloat</span>)blue&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> imageWidth = image.size.width;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> imageHeight = image.size.height;</span><br><span class="line">    size_t bytesPerRow = imageWidth * <span class="number">4</span>;</span><br><span class="line">    uint32_t* rgbImageBuf = (uint32_t*)malloc(bytesPerRow * imageHeight);</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(rgbImageBuf, imageWidth, imageHeight, <span class="number">8</span>, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipLast);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, imageWidth, imageHeight), image.CGImage); <span class="comment">// 遍历像素</span></span><br><span class="line">    <span class="keyword">int</span> pixelNum = imageWidth * imageHeight;</span><br><span class="line">    uint32_t* pCurPtr = rgbImageBuf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pixelNum; i++, pCurPtr++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((*pCurPtr &amp; <span class="number">0xFFFFFF00</span>) &lt; <span class="number">0x99999900</span>) <span class="comment">// 将白色变成透明</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 改成下面的代码，会将图片转成想要的颜色</span></span><br><span class="line">        uint8_t* ptr = (uint8_t*)pCurPtr;</span><br><span class="line">        ptr[<span class="number">3</span>] = red; <span class="comment">//0~255</span></span><br><span class="line">        ptr[<span class="number">2</span>] = green;</span><br><span class="line">        ptr[<span class="number">1</span>] = blue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        uint8_t* ptr = (uint8_t*)pCurPtr;</span><br><span class="line">        ptr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出图片</span></span><br><span class="line">    <span class="built_in">CGDataProviderRef</span> dataProvider = <span class="built_in">CGDataProviderCreateWithData</span>(<span class="literal">NULL</span>, rgbImageBuf, bytesPerRow * imageHeight, <span class="literal">nil</span>);</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGImageCreate</span>(imageWidth, imageHeight, <span class="number">8</span>, <span class="number">32</span>, bytesPerRow, colorSpace, kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, <span class="literal">NULL</span>, <span class="literal">true</span>, kCGRenderingIntentDefault);</span><br><span class="line">    <span class="built_in">CGDataProviderRelease</span>(dataProvider);</span><br><span class="line">    <span class="built_in">UIImage</span>* resultUIImage = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef]; <span class="comment">// 清理空间</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(imageRef);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    <span class="keyword">return</span> resultUIImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扫码"><a href="#扫码" class="headerlink" title="扫码"></a>扫码</h3><p>　　扫码主要用到的是AVFoundation用到的东西和相机基本相同，相机请参考我的另外一篇文章<br><img src="http://upload-images.jianshu.io/upload_images/966908-4540ac0268f17202.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-04-11 上午11.46.38.png"></p>
<h4 id="声明以下对象，遵守AVCaptureMetadataOutputObjectsDelegate"><a href="#声明以下对象，遵守AVCaptureMetadataOutputObjectsDelegate" class="headerlink" title="声明以下对象，遵守AVCaptureMetadataOutputObjectsDelegate"></a>声明以下对象，遵守AVCaptureMetadataOutputObjectsDelegate</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ScanQRViewController</span> ()&lt;<span class="title">AVCaptureMetadataOutputObjectsDelegate</span>&gt;</span></span><br><span class="line"><span class="comment">//捕获设备，通常是前置摄像头，后置摄像头，麦克风（音频输入）</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">AVCaptureDevice</span> *device;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AVCaptureDeviceInput 代表输入设备，他使用AVCaptureDevice 来初始化</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">AVCaptureDeviceInput</span> *input;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置输出类型为Metadata，因为这种输出类型中可以设置扫描的类型，譬如二维码</span></span><br><span class="line"><span class="comment">//当启动摄像头开始捕获输入时，如果输入中包含二维码，就会产生输出</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">AVCaptureMetadataOutput</span> *output;</span><br><span class="line"></span><br><span class="line"><span class="comment">//session：由他把输入输出结合在一起，并开始启动捕获设备（摄像头）</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">AVCaptureSession</span> *session;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图像预览层，实时显示捕获的图像</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)<span class="built_in">AVCaptureVideoPreviewLayer</span> *previewLayer;</span><br></pre></td></tr></table></figure>
<h4 id="初始化各对象，输入输出设备结合"><a href="#初始化各对象，输入输出设备结合" class="headerlink" title="初始化各对象，输入输出设备结合"></a>初始化各对象，输入输出设备结合</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)creatCaptureDevice&#123;</span><br><span class="line">    <span class="comment">//使用AVMediaTypeVideo 指明self.device代表视频，默认使用后置摄像头进行初始化</span></span><br><span class="line">    <span class="keyword">self</span>.device = [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用设备初始化输入</span></span><br><span class="line">    <span class="keyword">self</span>.input = [[<span class="built_in">AVCaptureDeviceInput</span> alloc]initWithDevice:<span class="keyword">self</span>.device error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成输出对象</span></span><br><span class="line">    <span class="keyword">self</span>.output = [[<span class="built_in">AVCaptureMetadataOutput</span> alloc]init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置代理，一旦扫描到指定类型的数据，就会通过代理输出</span></span><br><span class="line">    <span class="comment">//在扫描的过程中，会分析扫描的内容，分析成功后就会调用代理方法在队列中输出</span></span><br><span class="line">    [<span class="keyword">self</span>.output setMetadataObjectsDelegate:<span class="keyword">self</span> queue:dispatch_get_main_queue()];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成会话，用来结合输入输出</span></span><br><span class="line">    <span class="keyword">self</span>.session = [[<span class="built_in">AVCaptureSession</span> alloc]init];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.session canAddInput:<span class="keyword">self</span>.input]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session addInput:<span class="keyword">self</span>.input];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.session canAddOutput:<span class="keyword">self</span>.output]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session addOutput:<span class="keyword">self</span>.output];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定当扫描到二维码的时候，产生输出</span></span><br><span class="line">    <span class="comment">//AVMetadataObjectTypeQRCode 指定二维码</span></span><br><span class="line">    <span class="comment">//指定识别类型一定要放到添加到session之后</span></span><br><span class="line">    [<span class="keyword">self</span>.output setMetadataObjectTypes:@[<span class="built_in">AVMetadataObjectTypeQRCode</span>]];</span><br><span class="line"><span class="comment">//设置扫描信息的识别区域，左上角为(0,0),右下角为(1,1),不设的话全屏都可以识别。设置过之后可以缩小信息扫描面积加快识别速度。</span></span><br><span class="line"><span class="comment">//这个属性并不好设置，整了半天也没太搞明白，到底x,y,width,height,怎么是对应的，这是我一点一点试的扫描区域，看不到只能调一下，扫一扫试试</span></span><br><span class="line">    [<span class="keyword">self</span>.output setRectOfInterest:<span class="built_in">CGRectMake</span>(<span class="number">0.1</span> ,<span class="number">0.3</span> , <span class="number">0.4</span>, <span class="number">0.4</span>)];</span><br><span class="line">    <span class="comment">//使用self.session，初始化预览层，self.session负责驱动input进行信息的采集，layer负责把图像渲染显示</span></span><br><span class="line">    <span class="keyword">self</span>.previewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc]initWithSession:<span class="keyword">self</span>.session];</span><br><span class="line">    <span class="keyword">self</span>.previewLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, kScreenWidth , kScreenHeight);</span><br><span class="line">    <span class="keyword">self</span>.previewLayer.videoGravity = <span class="built_in">AVLayerVideoGravityResizeAspectFill</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:<span class="keyword">self</span>.previewLayer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始启动</span></span><br><span class="line">    [<span class="keyword">self</span>.session startRunning];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现代理方法"><a href="#实现代理方法" class="headerlink" title="实现代理方法"></a>实现代理方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark 输出的代理</span></span><br><span class="line"><span class="comment">//metadataObjects ：把识别到的内容放到该数组中</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput didOutputMetadataObjects:(<span class="built_in">NSArray</span> *)metadataObjects fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//停止扫描</span></span><br><span class="line">    [<span class="keyword">self</span>.session stopRunning];</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span>.lineView removeFromSuperview];</span><br><span class="line">    <span class="keyword">if</span> ([metadataObjects count] &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//数组中包含的都是AVMetadataMachineReadableCodeObject 类型的对象，该对象中包含解码后的数据</span></span><br><span class="line">        <span class="built_in">AVMetadataMachineReadableCodeObject</span> *qrObject = [metadataObjects lastObject];</span><br><span class="line">        拿到扫描内容在这里进行个性化处理</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"识别成功%@"</span>,qrObject.stringValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遇到的问题和解决办法"><a href="#遇到的问题和解决办法" class="headerlink" title="遇到的问题和解决办法"></a>遇到的问题和解决办法</h3><p>（1）二维码上加logo图的时候，图片很模糊，这是由于UIGraphicsBeginImageContextWithOptions里的 scale 造成的，由于 iPhone 的屏幕都是retina屏幕，都是2倍，3倍像素，这里的 scale 要根据屏幕来设置 即[[UIScreen mainScreen] scale]这样图片就会很清晰<br>（2）setRectOfInterest：设置扫描信息的识别区域，左上角为(0,0),右下角为(1,1),不设的话全屏都可以识别。设置过之后可以缩小信息扫描面积加快识别速度，原来扫描的是整个屏幕的大小，这时候只扫描一块区域，以此加快识别速度。但是这个属性并不好设置，整了半天也没太搞明白，到底x,y,width,height,怎么是对应的，而且是比例不是直接的数字，我是一点一点试的扫描区域，看不到情况，只能调一下，扫一扫试试<br>最后也没整明白，哪位大神知道，求解答<br>附上官方解释:<br>    The value of this property is a CGRect that determines the receiver’s rectangle of interest for each frame of video.<br>    The rectangle’s origin is top left and is relative to the coordinate space of the device providing the metadata.  Specifying<br>    a rectOfInterest may improve detection performance for certain types of metadata. The default value of this property is the<br>    value CGRectMake(0, 0, 1, 1).  Metadata objects whose bounds do not intersect with the rectOfInterest will not be returned.</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[30分钟搞定iOS自定义相机]]></title>
      <url>http://nanshanyi.github.io/2016/05/07/xiangji/</url>
      <content type="html"><![CDATA[<p>　　最近公司的项目中用到了相机，由于不用系统的相机，UI给的相机切图，必须自定义才可以。就花时间简单研究了一下相机的自定义。<br>　　相机属于系统硬件，这就需要我们来手动调用iPhone的相机硬件，分为以下步骤：<br><a id="more"></a><br><img src="/2016/05/07/xiangji/camera.png" alt></p>
<h4 id="首先声明以下对象"><a href="#首先声明以下对象" class="headerlink" title="首先声明以下对象"></a>首先声明以下对象</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"><span class="comment">//捕获设备，通常是前置摄像头，后置摄像头，麦克风（音频输入）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVCaptureDevice</span> *device;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AVCaptureDeviceInput 代表输入设备，他使用AVCaptureDevice 来初始化</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVCaptureDeviceInput</span> *input;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出图片</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> ,<span class="keyword">strong</span>) <span class="built_in">AVCaptureStillImageOutput</span> *imageOutput;</span><br><span class="line"></span><br><span class="line"><span class="comment">//session：由他把输入输出结合在一起，并开始启动捕获设备（摄像头）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVCaptureSession</span> *session;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图像预览层，实时显示捕获的图像</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> ,<span class="keyword">strong</span>) <span class="built_in">AVCaptureVideoPreviewLayer</span> *previewLayer;</span><br></pre></td></tr></table></figure>
<h4 id="初始化各个对象"><a href="#初始化各个对象" class="headerlink" title="初始化各个对象"></a>初始化各个对象</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cameraDistrict</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    AVCaptureDevicePositionBack  后置摄像头</span></span><br><span class="line"><span class="comment">//    AVCaptureDevicePositionFront 前置摄像头</span></span><br><span class="line">   <span class="keyword">self</span>.device = [<span class="keyword">self</span> cameraWithPosition:<span class="built_in">AVCaptureDevicePositionFront</span>];</span><br><span class="line">    <span class="keyword">self</span>.input = [[<span class="built_in">AVCaptureDeviceInput</span> alloc] initWithDevice:<span class="keyword">self</span>.device error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.imageOutput = [[<span class="built_in">AVCaptureStillImageOutput</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</span><br><span class="line">    <span class="comment">//     拿到的图像的大小可以自行设定</span></span><br><span class="line">    <span class="comment">//    AVCaptureSessionPreset320x240</span></span><br><span class="line">    <span class="comment">//    AVCaptureSessionPreset352x288</span></span><br><span class="line">    <span class="comment">//    AVCaptureSessionPreset640x480</span></span><br><span class="line">    <span class="comment">//    AVCaptureSessionPreset960x540</span></span><br><span class="line">    <span class="comment">//    AVCaptureSessionPreset1280x720</span></span><br><span class="line">    <span class="comment">//    AVCaptureSessionPreset1920x1080</span></span><br><span class="line">    <span class="comment">//    AVCaptureSessionPreset3840x2160</span></span><br><span class="line">    <span class="keyword">self</span>.session.sessionPreset = <span class="built_in">AVCaptureSessionPreset640x480</span>;</span><br><span class="line">    <span class="comment">//输入输出设备结合</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.session canAddInput:<span class="keyword">self</span>.input]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session addInput:<span class="keyword">self</span>.input];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.session canAddOutput:<span class="keyword">self</span>.imageOutput]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.session addOutput:<span class="keyword">self</span>.imageOutput];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预览层的生成</span></span><br><span class="line">    <span class="keyword">self</span>.previewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:<span class="keyword">self</span>.session];</span><br><span class="line">    <span class="keyword">self</span>.previewLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">64</span>, SCREEN_WIDTH, SCREEN_HEIGHT<span class="number">-64</span>);</span><br><span class="line">    <span class="keyword">self</span>.previewLayer.videoGravity = <span class="built_in">AVLayerVideoGravityResizeAspectFill</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:<span class="keyword">self</span>.previewLayer];</span><br><span class="line">    <span class="comment">//设备取景开始</span></span><br><span class="line">    [<span class="keyword">self</span>.session startRunning];</span><br><span class="line">    <span class="keyword">if</span> ([_device lockForConfiguration:<span class="literal">nil</span>]) &#123;</span><br><span class="line">    <span class="comment">//自动闪光灯，</span></span><br><span class="line">        <span class="keyword">if</span> ([_device isFlashModeSupported:<span class="built_in">AVCaptureFlashModeAuto</span>]) &#123;</span><br><span class="line">            [_device setFlashMode:<span class="built_in">AVCaptureFlashModeAuto</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//自动白平衡,但是好像一直都进不去</span></span><br><span class="line">        <span class="keyword">if</span> ([_device isWhiteBalanceModeSupported:<span class="built_in">AVCaptureWhiteBalanceModeAutoWhiteBalance</span>]) &#123;</span><br><span class="line">            [_device setWhiteBalanceMode:<span class="built_in">AVCaptureWhiteBalanceModeAutoWhiteBalance</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [_device unlockForConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  根据前后置位置拿到相应的摄像头：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">AVCaptureDevice</span> *)cameraWithPosition:(<span class="built_in">AVCaptureDevicePosition</span>)position&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devicesWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices )</span><br><span class="line">        <span class="keyword">if</span> ( device.position == position )&#123;</span><br><span class="line">            <span class="keyword">return</span> device;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="拍照拿到相应图片："><a href="#拍照拿到相应图片：" class="headerlink" title="拍照拿到相应图片："></a>拍照拿到相应图片：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)photoBtnDidClick</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">AVCaptureConnection</span> *conntion = [<span class="keyword">self</span>.imageOutput connectionWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line">      <span class="keyword">if</span> (!conntion) &#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"拍照失败!"</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">    [<span class="keyword">self</span>.imageOutput captureStillImageAsynchronouslyFromConnection:conntion completionHandler:^(<span class="built_in">CMSampleBufferRef</span> imageDataSampleBuffer, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imageDataSampleBuffer == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="built_in">NSData</span> *imageData = [<span class="built_in">AVCaptureStillImageOutput</span> jpegStillImageNSDataRepresentation:imageDataSampleBuffer];</span><br><span class="line">        <span class="keyword">self</span>.image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line">        [<span class="keyword">self</span>.session stopRunning];</span><br><span class="line">        [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.cameraImageView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="保存照片到相册："><a href="#保存照片到相册：" class="headerlink" title="保存照片到相册："></a>保存照片到相册：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> - 保存至相册</span></span><br><span class="line">- (<span class="keyword">void</span>)saveImageToPhotoAlbum:(<span class="built_in">UIImage</span>*)savedImage</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImageWriteToSavedPhotosAlbum</span>(savedImage, <span class="keyword">self</span>, <span class="keyword">@selector</span>(image:didFinishSavingWithError:contextInfo:), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定回调方法</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)image: (<span class="built_in">UIImage</span> *) image didFinishSavingWithError: (<span class="built_in">NSError</span> *) error contextInfo: (<span class="keyword">void</span> *) contextInfo</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *msg = <span class="literal">nil</span> ;</span><br><span class="line">    <span class="keyword">if</span>(error != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        msg = <span class="string">@"保存图片失败"</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        msg = <span class="string">@"保存图片成功"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"保存图片结果提示"</span></span><br><span class="line">                                            message:msg</span><br><span class="line">                                            delegate:<span class="keyword">self</span></span><br><span class="line">                                          cancelButtonTitle:<span class="string">@"确定"</span></span><br><span class="line">                                          otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">    [alert show];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前后置摄像头的切换"><a href="#前后置摄像头的切换" class="headerlink" title="前后置摄像头的切换"></a>前后置摄像头的切换</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)changeCamera&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> cameraCount = [[<span class="built_in">AVCaptureDevice</span> devicesWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] count];</span><br><span class="line">    <span class="keyword">if</span> (cameraCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="comment">//给摄像头的切换添加翻转动画</span></span><br><span class="line">        <span class="built_in">CATransition</span> *animation = [<span class="built_in">CATransition</span> animation]；</span><br><span class="line">        animation.duration = <span class="number">.5</span>f；</span><br><span class="line">        animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">        animation.type = <span class="string">@"oglFlip"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AVCaptureDevice</span> *newCamera = <span class="literal">nil</span>;</span><br><span class="line">        <span class="built_in">AVCaptureDeviceInput</span> *newInput = <span class="literal">nil</span>;</span><br><span class="line">  <span class="comment">//拿到另外一个摄像头位置</span></span><br><span class="line">        <span class="built_in">AVCaptureDevicePosition</span> position = [[_input device] position];</span><br><span class="line">        <span class="keyword">if</span> (position == <span class="built_in">AVCaptureDevicePositionFront</span>)&#123;</span><br><span class="line">            newCamera = [<span class="keyword">self</span> cameraWithPosition:<span class="built_in">AVCaptureDevicePositionBack</span>];</span><br><span class="line">            animation.subtype = kCATransitionFromLeft;<span class="comment">//动画翻转方向</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            newCamera = [<span class="keyword">self</span> cameraWithPosition:<span class="built_in">AVCaptureDevicePositionFront</span>];</span><br><span class="line">            animation.subtype = kCATransitionFromRight;<span class="comment">//动画翻转方向</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生成新的输入</span></span><br><span class="line">        newInput = [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:newCamera error:<span class="literal">nil</span>];</span><br><span class="line">        [<span class="keyword">self</span>.previewLayer addAnimation:animation forKey:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">if</span> (newInput != <span class="literal">nil</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.session beginConfiguration];</span><br><span class="line">            [<span class="keyword">self</span>.session removeInput:<span class="keyword">self</span>.input];</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.session canAddInput:newInput]) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.session addInput:newInput];</span><br><span class="line">                <span class="keyword">self</span>.input = newInput;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [<span class="keyword">self</span>.session addInput:<span class="keyword">self</span>.input];</span><br><span class="line">            &#125;</span><br><span class="line">            [<span class="keyword">self</span>.session commitConfiguration];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"toggle carema failed, error = %@"</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="相机的其它参数设置"><a href="#相机的其它参数设置" class="headerlink" title="相机的其它参数设置"></a>相机的其它参数设置</h4><pre><code class="objectivec"><span class="comment">//AVCaptureFlashMode  闪光灯</span>
<span class="comment">//AVCaptureFocusMode  对焦</span>
<span class="comment">//AVCaptureExposureMode  曝光</span>
<span class="comment">//AVCaptureWhiteBalanceMode  白平衡</span>
<span class="comment">//闪光灯和白平衡可以在生成相机时候设置</span>
<span class="comment">//曝光要根据对焦点的光线状况而决定,所以和对焦一块写</span>
<span class="comment">//point为点击的位置</span>
- (<span class="keyword">void</span>)focusAtPoint:(<span class="built_in">CGPoint</span>)point{
    <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.view.bounds.size;
    <span class="built_in">CGPoint</span> focusPoint = <span class="built_in">CGPointMake</span>( point.y /size.height ,<span class="number">1</span>-point.x/size.width );
    <span class="built_in">NSError</span> *error;
    <span class="keyword">if</span> ([<span class="keyword">self</span>.device lockForConfiguration:&amp;error]) {
        <span class="comment">//对焦模式和对焦点</span>
        <span class="keyword">if</span> ([<span class="keyword">self</span>.device isFocusModeSupported:<span class="built_in">AVCaptureFocusModeAutoFocus</span>]) {
            [<span class="keyword">self</span>.device setFocusPointOfInterest:focusPoint];
            [<span class="keyword">self</span>.device setFocusMode:<span class="built_in">AVCaptureFocusModeAutoFocus</span>];
        }
        <span class="comment">//曝光模式和曝光点</span>
        <span class="keyword">if</span> ([<span class="keyword">self</span>.device isExposureModeSupported:<span class="built_in">AVCaptureExposureModeAutoExpose</span> ]) {
            [<span class="keyword">self</span>.device setExposurePointOfInterest:focusPoint];
            [<span class="keyword">self</span>.device setExposureMode:<span class="built_in">AVCaptureExposureModeAutoExpose</span>];
        }

        [<span class="keyword">self</span>.device unlockForConfiguration];
        <span class="comment">//设置对焦动画</span>
        _focusView.center = point;
        _focusView.hidden = <span class="literal">NO</span>;
        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> animations:^{
            _focusView.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.25</span>, <span class="number">1.25</span>);
        }completion:^(<span class="built_in">BOOL</span> finished) {
            [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> animations:^{
                _focusView.transform = <span class="built_in">CGAffineTransformIdentity</span>;
            } completion:^(<span class="built_in">BOOL</span> finished) {
                _focusView.hidden = <span class="literal">YES</span>;
            }];
        }];
    }

}
</code></pre>
<h4 id="遇到的一些坑和解决办法"><a href="#遇到的一些坑和解决办法" class="headerlink" title="遇到的一些坑和解决办法"></a>遇到的一些坑和解决办法</h4><h5 id="1-前后置摄像头的切换"><a href="#1-前后置摄像头的切换" class="headerlink" title="1) 前后置摄像头的切换"></a>1) 前后置摄像头的切换</h5><p>　　前后值不能切换，各种尝试找了半天没找到有原因。后来发现我在设置图片尺寸的时候设置为1080P [self.session canSetSessionPreset: AVCaptureSessionPreset1920x1080]   ，前置摄像头并不支持这么大的尺寸，所以就不能切换前置摄像头。我验证了下 前置摄像头最高支持720P,720P以内可自由切换。　　当然也可以在前后置摄像头切换的时候，根据前后摄像头来设置不同的尺寸，这里不在赘述。</p>
<h5 id="2）焦点位置"><a href="#2）焦点位置" class="headerlink" title="2）焦点位置"></a>2）焦点位置</h5><p>　　CGPoint focusPoint = CGPointMake( point.y /size.height ,1-point.x/size.width );<br>setExposurePointOfInterest：focusPoint 函数后面Point取值范围是取景框左上角（0，0）到取景框右下角（1，1）之间。官方是这么写的：<br>　　The value of this property is a CGPoint that determines the receiver’s focus point of interest, if it has one. A value of (0,0) indicates that the camera should focus on the top left corner of the image, while a value of (1,1) indicates that it should focus on the bottom right. The default value is (0.5,0.5).<br>　　我也试了按这个来但位置就是不对，只能按上面的写法才可以。前面是点击位置的y/PreviewLayer的高度，后面是1-点击位置的x/PreviewLayer的宽度</p>
<h5 id="3）对焦和曝光"><a href="#3）对焦和曝光" class="headerlink" title="3）对焦和曝光"></a>3）对焦和曝光</h5><p>　　我在设置对焦是 先设置了模式setFocusMode，后设置对焦位置，就会导致很奇怪的现象，对焦位置是你上次点击的位置。所以一定要先设置位置，再设置对焦模式。<br>　　曝光同上</p>
<h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>　　附上 <a href="https://github.com/nanshanyi/photographDemo" target="_blank" rel="noopener">demo</a><br>　　常用到的基本就这么多，写的并不完善，有什么不对的，欢迎大家批评指正，共同学习。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[3DTouch应用详解]]></title>
      <url>http://nanshanyi.github.io/2016/04/20/3dtouch/</url>
      <content type="html"><![CDATA[<p>3D touch也出了很长时间了，这次花时间好好研究了一下，把经验与大家分享一下</p>
<h4 id="主界面重按APP图标，弹出Touch菜单"><a href="#主界面重按APP图标，弹出Touch菜单" class="headerlink" title="主界面重按APP图标，弹出Touch菜单"></a>主界面重按APP图标，弹出Touch菜单</h4><p>　静态快速选项<br>　　　(iOS数组)给APP指定静态主屏幕的快速选项，这个键包含了一个字典数组，每个字典包含关于一个快速选项的详细信息。你可以指定静态快速选项给你的APP用一个字典数组。<br><img src="/2016/04/20/3dtouch/966908-a293ac389bddf444.png" alt><br>　UIApplicationShortcutItems (iOS数组)给APP指定静态主屏幕的快速选项，这个键包含了一个字典数组，每个字典包含关于一个快速选项的详细信息。你可以指定静态快速选项给你的APP用一个字典数组。<br><a id="more"></a><br>静态定义快速在运行时常用的key:<br>UIApplicationShortcutItemType (必须使用) 用来区分与其他快速选项的分类<br>UIApplicationShortcutItemTitle (必须使用) 快速选项显示的标题<br>UIApplicationShortcutItemSubtitle 快速选项显示的子标题<br>UIApplicationShortcutItemIconType 图片类型由系统提供（ iOS9.1之后新添加了许多图片类型）<br>UIApplicationShortcutItemIconFile 自定义的图标<br>UIApplicationShortcutItemUserInfo 附加信息</p>
<h4 id="动态快速选项"><a href="#动态快速选项" class="headerlink" title="动态快速选项"></a>动态快速选项</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line"><span class="built_in">UIApplicationShortcutItem</span> * item = [[<span class="built_in">UIApplicationShortcutItem</span> alloc]initWithType:<span class="string">@"two"</span> localizedTitle:<span class="string">@"搜索"</span> localizedSubtitle:<span class="string">@"一步到达指定地点"</span> icon:[<span class="built_in">UIApplicationShortcutIcon</span> iconWithType:<span class="built_in">UIApplicationShortcutIconTypeSearch</span>] userInfo:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">UIApplicationShortcutItem</span> * item1 = [[<span class="built_in">UIApplicationShortcutItem</span> alloc]initWithType:<span class="string">@"three"</span> localizedTitle:<span class="string">@"附近"</span> localizedSubtitle:<span class="string">@"好吃的"</span> icon:[<span class="built_in">UIApplicationShortcutIcon</span> iconWithType:<span class="built_in">UIApplicationShortcutIconTypeMarkLocation</span>] userInfo:<span class="literal">nil</span>];</span><br><span class="line">[<span class="built_in">UIApplication</span> sharedApplication].shortcutItems = @[item,item1];</span><br></pre></td></tr></table></figure>
<p><img src="/2016/04/20/3dtouch/966908-b0ccf43482e4f83d.png" alt></p>
<h4 id="选择item后触发的方法"><a href="#选择item后触发的方法" class="headerlink" title="选择item后触发的方法"></a>选择item后触发的方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="keyword">nonnull</span>     <span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">nonnull</span> <span class="keyword">void</span>   (^)(<span class="built_in">BOOL</span>))completionHandler&#123;</span><br><span class="line">　　<span class="comment">//通过shortcutItem.type来判断点击的是哪一个item，来进行不同的操作</span></span><br><span class="line">  <span class="keyword">if</span> ([shortcutItem.type isEqualToString:<span class="string">@"one"</span>]) &#123;</span><br><span class="line">        <span class="built_in">UITabBarController</span> *mytab = (<span class="built_in">UITabBarController</span>*)<span class="keyword">self</span>.window.rootViewController;</span><br><span class="line">        mytab.selectedIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([shortcutItem.type isEqualToString:<span class="string">@"two"</span>])&#123;</span><br><span class="line">        SearchVC *searchVC = [[SearchVC alloc]init];</span><br><span class="line">        <span class="built_in">UITabBarController</span> *mytab = (<span class="built_in">UITabBarController</span>*)<span class="keyword">self</span>.window.rootViewController;</span><br><span class="line">        <span class="built_in">UINavigationController</span> *myNAV = [mytab.viewControllers firstObject];</span><br><span class="line">      [myNAV pushViewController:searchVC animated:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// [self.window.rootViewController presentViewController:searchVC animated:YES completion:nil];</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      FPHNearbyVC *vc = [[FPHNearbyVC alloc] init];</span><br><span class="line">      <span class="built_in">UITabBarController</span> *mytab = (<span class="built_in">UITabBarController</span>*)<span class="keyword">self</span>.window.rootViewController;</span><br><span class="line">      <span class="built_in">UINavigationController</span> *myNAV = [mytab.viewControllers firstObject];</span><br><span class="line">      vc.hidesBottomBarWhenPushed = <span class="literal">YES</span>;</span><br><span class="line">       [myNAV pushViewController:vc animated:<span class="literal">YES</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     completionHandler(<span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="APP内部peek和pop的使用（以tableView中的使用为例）"><a href="#APP内部peek和pop的使用（以tableView中的使用为例）" class="headerlink" title="APP内部peek和pop的使用（以tableView中的使用为例）"></a>APP内部peek和pop的使用（以tableView中的使用为例）</h4><p>　　首先遵守协议UIViewControllerPreviewingDelegate<br>　　检测是否有3Dtouch；<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)check3DTouch&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.traitCollection.forceTouchCapability == <span class="built_in">UIForceTouchCapabilityAvailable</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"3D Touch 开启"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>　　下面来实现相应的代理方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//peek的代理方法，轻按即可触发弹出vc</span></span><br><span class="line"> - (<span class="built_in">UIViewController</span> *)previewingContext:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext viewControllerForLocation:(<span class="built_in">CGPoint</span>)location&#123;</span><br><span class="line">     <span class="built_in">NSIndexPath</span> *indexPath = [_tableView indexPathForCell:(<span class="built_in">UITableViewCell</span>* )[previewingContext sourceView]];</span><br><span class="line"><span class="comment">//通过[previewingContext sourceView]拿到对应的cell；　　</span></span><br><span class="line">  NewVC *vc = [[FPHNewHouseDetailVC alloc] init];</span><br><span class="line">  newModel *model= [_tableView objectAtIndex:indexPath.row];</span><br><span class="line">  vc.pid = house.id;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,location);</span><br><span class="line">  <span class="keyword">return</span> vc;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//pop的代理方法，在此处可对将要进入的vc进行处理，比如隐藏tabBar；</span></span><br><span class="line"> - (<span class="keyword">void</span>)previewingContext:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext commitViewController:(<span class="built_in">UIViewController</span> *)viewControllerToCommit</span><br><span class="line"> &#123;</span><br><span class="line">     viewControllerToCommit.hidesBottomBarWhenPushed = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> showViewController:viewControllerToCommit sender:<span class="keyword">self</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> <strong>注意：</strong>tableView在<br>　　　　- (UITableViewCell<em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath<br>　　方法中一定要对每个cell进行注册代理方法如下<br>　　[self registerForPreviewingWithDelegate:self sourceView:cell];</p>
<h4 id="预览时底部菜单的添加"><a href="#预览时底部菜单的添加" class="headerlink" title="预览时底部菜单的添加"></a>预览时底部菜单的添加</h4><p>在要预览的VC中添加以下代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;<span class="built_in">UIPreviewActionItem</span>&gt;&gt; *)previewActionItems</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">UIPreviewAction</span> * action1 = [<span class="built_in">UIPreviewAction</span> actionWithTitle:<span class="string">@"标题1"</span> style:<span class="number">1</span> handler:^(<span class="built_in">UIPreviewAction</span> * _Nonnull action, <span class="built_in">UIViewController</span> * _Nonnull previewViewController) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"标题1"</span>);</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIPreviewAction</span> * action2 = [<span class="built_in">UIPreviewAction</span> actionWithTitle:<span class="string">@"标题2"</span> style:<span class="number">0</span> handler:^(<span class="built_in">UIPreviewAction</span> * _Nonnull action, <span class="built_in">UIViewController</span> * _Nonnull previewViewController) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"标题2"</span>);</span><br><span class="line"></span><br><span class="line"> &#125;];</span><br><span class="line"><span class="built_in">UIPreviewAction</span> * action3 = [<span class="built_in">UIPreviewAction</span> actionWithTitle:<span class="string">@"标题3"</span> style:<span class="number">2</span> handler:^(<span class="built_in">UIPreviewAction</span> * _Nonnull action, <span class="built_in">UIViewController</span> * _Nonnull previewViewController) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"标题3"</span>);</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> * actions = @[action1,action2,action3];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> actions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　　　block里面直接写点击后要实现的操作<br>最终效果：<br><img src="/2016/04/20/3dtouch/966908-976af00f57dd4439.png" alt><br> 　　暂时就写这么多，有什么不对的地方请大家指教，大家互相学习。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
